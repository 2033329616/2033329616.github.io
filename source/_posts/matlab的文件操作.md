---
title: matlab的文件操作
tags: [fopen, matlab]
categories: 
- matlab
comments: true
sitemap: false
grammar_cjkRuby: true
---
2018-5-9

### **1. fopen、fprintf与fscanf的用法**
* FID = fopen(file_name, mode)

> 参数：
> file_name：输入文件的名字，以字符串的形式读入
> mode：读入文件的模式，如下表所示

| mode  | 功能          |
| --- | ------------------------------------------------- |
|  r  | 只读                                               |
| w   | 覆盖式写入文件，如果文件不存在就创建该文件   |
| a   | 添加式写入，不清除原文件，直接在该文件后面续写 |
| r+  | 打开已经存在的文件来进行读写                                   |
| w+  | 重新刷新读入与写入                                 |
| a+  | 对文件进行添加式读写操作， 如果文件不存在就创建该文件                                  |
在写入文件时，如果该文件不存在则会创建该文件，文件打开的默认存储格式是二进制的，如果以文本方式打开，则在mode中加入`t`，例如'rt'或'wt'
>返回值：
>FID=n，如果n是正整数，则表示读入文件成功且n表示文件**代号**，如果FID=-1则读入文件失败，FID类似于python中的文件对象，在文件关闭前FID都是有效的。

示例：
```matlab
fid = fopen('test.txt','w+')   % 打开一个文件，返回的fid为一个正整数，假设为fid=7
fclose(fid)                    % 关闭文件号为fid=7的文件
```
**fopen()函数仅打开了一个文件并返回其文件代号，但无法直接读取文件的内容，所以需要使用fscanf()函数来将文件代号对应文件中的内容读入到字符串变量中，类似于python文件中的readline()函数**

* [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE, SIZE)

> 参数：
> FID：为fopen()函数返回的文件代号
> TEMPLAGE：输入数据的格式，如下表所示
>  SIZE：该参数是针对读取文件内容篇幅的，将文本当做矩阵，SIZE表示返回VAL矩阵的行列值,**从原文件读入数据是按照行进行，但是在返回VAL时会将数据按列优先来排列，直到满足SIZE，然后忽略其余数据**，SIZE除了取[m,n]类型外，也可以直接取数，取的数决定了VAL的数据的量，如果为**inf**则直接读取文件的所以内容

表-1 格式描述符
| TEMPLATE类型  |         功能  |
| --- | ------------------------------------------------- |
|  %d  | 整数                                               |
| %e  | 实数，科学计数法形式   |
| %f| 实数，小数形式|
| %g|会输出整数或实数，由数本身决定，但末尾的0会省去 |
| %s| 输出字符串格式|
|   %c | 输出字符格式| 
>返回值：
>VAL：返回的文件内容，可以是字符串也可以是数字
>COUNT：返回的字符串或数字的个数
>ERRMSG：当读取文件失败时才会输出stream not open for reading，读入文件正确时该项为空

示例：
 test.txt文件中内容如下：
 1   2   3
 4   5   6
 7   8   9
 10 11 12
 
![fscanf读取文件内容](http://p7jji9nvf.bkt.clouddn.com/小书匠/fscanf2.jpg)

读取文件时类型混合无法直接读取，
文件如下：
1 hello
2 world
3 happy
只能分别使用`fscanf(fid, '%d', 1)`与`fscanf(fid, '%s', 1)`按数据类型逐个读入数据(这里使用octave实验)。

这里需要注意，每次使用fscanf()函数读取文件后，文件的指针会移动到当前读取的位置，例如在test.txt示例中，文件指针当前指向**数据7**，所以必须将文件指针回到文件的开头才能再次使用该文件，这里使用fseek()函数来修改文件的指针
* status = fseek(fid, offset, origin)
> 参数：
> fid：文件代号或文件句柄
> offset：>0 向文件末尾移动；=0 保持位置不变； <0 向文件开头移动
> origin：文件位置指针移动的参考位置， ‘bof’ 或 -1表示文件的开头；‘cof’或0表示文件的当前位置；‘eof’或1表示文件的末尾
> 返回值：
> status=0表示改变指针位置成功，否则返回-1

* count = fprintf (fid, template, variable)
> 参数：
> fid：文件代号或文件句柄，当该项为空时，直接输出到屏幕中
> template：输出文件的格式，与输入的格式描述相同，见上表-1
> variable：要输出的变量
> 返回值：
> count：按文件描述符格式划分的数据个数