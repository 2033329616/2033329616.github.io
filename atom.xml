<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞奔的弹幕君</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2033329616.github.io/"/>
  <updated>2018-07-08T14:50:02.819Z</updated>
  <id>https://2033329616.github.io/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模型训练技巧</title>
    <link href="https://2033329616.github.io/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7.html"/>
    <id>https://2033329616.github.io/模型训练技巧.html</id>
    <published>2018-07-08T13:13:37.644Z</published>
    <updated>2018-07-08T14:50:02.819Z</updated>
    
    <content type="html"><![CDATA[<p>2018-7-8</p><h3 id="1-卷积神经网络"><a href="#1-卷积神经网络" class="headerlink" title="1. 卷积神经网络"></a>1. 卷积神经网络</h3><p>主要针对tensorflow框架</p><ol><li>使用 ADAM 优化器，如果你想要保存和恢复模型权重，请记住在设置完 AdamOptimizer 后设置 Saver，这是因为 ADAM 也有需要恢复的状态(即对应于每个权重的学习率)，通常选0.001的学习率比较好，该优化器已经考虑了梯度衰减，所以不用手动添加，因此即使减小学习率也没有太多的帮助</li><li>ReLU激活函数，可以解决梯度消失问题，并提高迭代的速度</li><li><strong>输出层后不要加激活函数</strong></li><li>使用方差缩放初始化，这种初始化方法比常规高斯分布初始化、截断高斯分布初始化及 Xavier 初始化的泛化/缩放性能更好</li><li>白化(归一化)输入数据，在训练中，令样本点的值减去数据集的均值，然后除以它的标准差</li><li>池化为了变换不变性(tansform invariance)，使网络学习图像的某个部分，卷积神经网络的池化可以起到对特征平移、旋转和缩放的鲁棒性</li><li><strong>批归一化可能隐藏初始化导致的梯度爆炸，所以可以将batch_size设置为1，删除归一化层观察梯度的变化</strong></li></ol><p>参考：<a href="https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_14896114614295638744%22%7D&amp;n_type=0&amp;p_from=1" target="_blank" rel="noopener">构建深度神经网络，我有20条「不成熟」的小建议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-7-8&lt;/p&gt;
&lt;h3 id=&quot;1-卷积神经网络&quot;&gt;&lt;a href=&quot;#1-卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;1. 卷积神经网络&quot;&gt;&lt;/a&gt;1. 卷积神经网络&lt;/h3&gt;&lt;p&gt;主要针对tensorflow框架&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
      <category term="模型训练" scheme="https://2033329616.github.io/categories/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
    
      <category term="模型训练" scheme="https://2033329616.github.io/tags/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>日积月累1</title>
    <link href="https://2033329616.github.io/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF.html"/>
    <id>https://2033329616.github.io/日积月累.html</id>
    <published>2018-06-15T02:47:52.315Z</published>
    <updated>2018-07-08T14:50:10.516Z</updated>
    
    <content type="html"><![CDATA[<p>2018-6-15</p><h3 id="1-条件随机场-CRF"><a href="#1-条件随机场-CRF" class="headerlink" title="1. 条件随机场(CRF)"></a>1. 条件随机场(CRF)</h3><p>&ensp;&ensp;特征函数仅使用当前单词和它前一个单词的标签对标注序列进行评价，这类CRF是最简单的线性链CRF</p><ol><li>首先定义<strong>特征函数</strong>集合，该函数以整个句子s、当前位置i、位置i和i-1的标签为输入</li><li>为每个特征函数赋予一个权重</li><li><p>对每个标注序列I，对所有的特征函数加权求和，而且可以将求和的结果经过softmax处理转换为概率值<br>评价函数为</p><script type="math/tex; mode=display">\sum_{i=1}^m\sum_{i=1}^n\lambda_jf_j(s,i,l_i,l_i-1)</script></li></ol><p>&ensp;&ensp;其中$\lambda_j$是第j个特征函数的权重，$f_j$是第j个特征函数，这里共m个特征函数，s表示句子，i表示句子中的第i个单词，$l_i$表示第l个标注序列给第i个单词标注的词性，$l_{i-1}$标注的第i-1个单词。外面的求和用来将所有特征函数的得分求和；里面的求和号用来将句子中每个单词的得分求和，对这个得分进行softmax得到每个标注序列的得分概率，公式如下</p><script type="math/tex; mode=display">p(l|s) = \frac{exp[score(l|s)]}{\sum_{l^`}exp[score(l^`|s)]}</script><blockquote><p>逻辑回归是用于分类的对数线性模型；条件随机场是用于<strong>序列化标注</strong>的对数线性模型</p></blockquote><h3 id="2-Keras中TimeDistributed层用法"><a href="#2-Keras中TimeDistributed层用法" class="headerlink" title="2.Keras中TimeDistributed层用法"></a>2.Keras中TimeDistributed层用法</h3><p>作者解释：TimeDistributed将同样的密集(全连接)操作应用到3D张量的每一个时间间隔上<br>LSTM的输入必须是3维或以上<br>如果将时序信号看作是2D矩阵，则TimeDistributed包装后的Dense就是分别对矩阵的每一行进行全连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-6-15&lt;/p&gt;
&lt;h3 id=&quot;1-条件随机场-CRF&quot;&gt;&lt;a href=&quot;#1-条件随机场-CRF&quot; class=&quot;headerlink&quot; title=&quot;1. 条件随机场(CRF)&quot;&gt;&lt;/a&gt;1. 条件随机场(CRF)&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;特
      
    
    </summary>
    
      <category term="日积月累" scheme="https://2033329616.github.io/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="日积月累" scheme="https://2033329616.github.io/tags/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>matlab的文件操作</title>
    <link href="https://2033329616.github.io/matlab%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html"/>
    <id>https://2033329616.github.io/matlab的文件操作.html</id>
    <published>2018-05-09T11:31:06.520Z</published>
    <updated>2018-05-10T14:03:33.546Z</updated>
    
    <content type="html"><![CDATA[<p>2018-5-9</p><h3 id="1-fopen、fprintf与fscanf的用法"><a href="#1-fopen、fprintf与fscanf的用法" class="headerlink" title="1. fopen、fprintf与fscanf的用法"></a><strong>1. fopen、fprintf与fscanf的用法</strong></h3><ul><li>FID = fopen(file_name, mode)</li></ul><blockquote><p>参数：<br>file_name：输入文件的名字，以字符串的形式读入<br>mode：读入文件的模式，如下表所示</p></blockquote><div class="table-container"><table><thead><tr><th>mode</th><th>功能</th></tr></thead><tbody><tr><td>r</td><td>只读</td></tr><tr><td>w</td><td>覆盖式写入文件，如果文件不存在就创建该文件</td></tr><tr><td>a</td><td>添加式写入，不清除原文件，直接在该文件后面续写</td></tr><tr><td>r+</td><td>打开已经存在的文件来进行读写</td></tr><tr><td>w+</td><td>重新刷新读入与写入</td></tr><tr><td>a+</td><td>对文件进行添加式读写操作， 如果文件不存在就创建该文件</td></tr></tbody></table></div><p>在写入文件时，如果该文件不存在则会创建该文件，文件打开的默认存储格式是二进制的，如果以文本方式打开，则在mode中加入<code>t</code>，例如’rt’或’wt’</p><blockquote><p>返回值：<br>FID=n，如果n是正整数，则表示读入文件成功且n表示文件<strong>代号</strong>，如果FID=-1则读入文件失败，FID类似于python中的文件对象，在文件关闭前FID都是有效的。</p></blockquote><p>示例：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'test.txt'</span>,<span class="string">'w+'</span>)   <span class="comment">% 打开一个文件，返回的fid为一个正整数，假设为fid=7</span></span><br><span class="line">fclose(fid)                    <span class="comment">% 关闭文件号为fid=7的文件</span></span><br></pre></td></tr></table></figure></p><p><strong>fopen()函数仅打开了一个文件并返回其文件代号，但无法直接读取文件的内容，所以需要使用fscanf()函数来将文件代号对应文件中的内容读入到字符串变量中，类似于python文件中的readline()函数</strong></p><ul><li>[VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE, SIZE)</li></ul><blockquote><p>参数：<br>FID：为fopen()函数返回的文件代号<br>TEMPLAGE：输入数据的格式，如下表所示<br> SIZE：该参数是针对读取文件内容篇幅的，将文本当做矩阵，SIZE表示返回VAL矩阵的行列值,<strong>从原文件读入数据是按照行进行，但是在返回VAL时会将数据按列优先来排列，直到满足SIZE，然后忽略其余数据</strong>，SIZE除了取[m,n]类型外，也可以直接取数，取的数决定了VAL的数据的量，如果为<strong>inf</strong>则直接读取文件的所以内容</p></blockquote><p>表-1 格式描述符</p><div class="table-container"><table><thead><tr><th>TEMPLATE类型</th><th>功能</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%e</td><td>实数，科学计数法形式</td></tr><tr><td>%f</td><td>实数，小数形式</td></tr><tr><td>%g</td><td>会输出整数或实数，由数本身决定，但末尾的0会省去</td></tr><tr><td>%s</td><td>输出字符串格式</td></tr><tr><td>%c</td><td>输出字符格式</td></tr></tbody></table></div><blockquote><p>返回值：<br>VAL：返回的文件内容，可以是字符串也可以是数字<br>COUNT：返回的字符串或数字的个数<br>ERRMSG：当读取文件失败时才会输出stream not open for reading，读入文件正确时该项为空</p></blockquote><p>示例：<br> test.txt文件中内容如下：<br> 1   2   3<br> 4   5   6<br> 7   8   9<br> 10 11 12<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> fid = fopen(<span class="string">'test.txt'</span>);</span><br><span class="line"> [f1, c1, e1] = fscanf(fid, <span class="string">'%d'</span>, [<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">% 输出如下</span></span><br><span class="line"><span class="comment">% f1 =</span></span><br><span class="line"><span class="comment">%      1 3 5</span></span><br><span class="line"><span class="comment">%      2 4 6</span></span><br><span class="line"><span class="comment">% c1 = 6</span></span><br><span class="line"><span class="comment">% e1 = </span></span><br><span class="line">fseek(fid, <span class="number">0</span>,<span class="number">-1</span>); <span class="comment">% 将文件位置指针指向文件头 </span></span><br><span class="line"><span class="comment">% 输出ans = 0</span></span><br><span class="line">[f1, c1, e1] = fscanf(fid, <span class="string">'%d'</span>, [<span class="number">3</span>,<span class="number">3</span>]);  <span class="comment">% 输出如下</span></span><br><span class="line"><span class="comment">% f1 =</span></span><br><span class="line"><span class="comment">%      1 4 7</span></span><br><span class="line"><span class="comment">%      2 5 8</span></span><br><span class="line"><span class="comment">%      3 6 9</span></span><br><span class="line"><span class="comment">% c1 = 6</span></span><br><span class="line"><span class="comment">% e1 =</span></span><br></pre></td></tr></table></figure></p><p>读取文件时类型混合无法直接读取，<br>文件如下：<br>1 hello<br>2 world<br>3 happy<br>只能分别使用<code>fscanf(fid, &#39;%d&#39;, 1)</code>与<code>fscanf(fid, &#39;%s&#39;, 1)</code>按数据类型逐个读入数据(这里使用octave实验)。</p><p>这里需要注意，每次使用fscanf()函数读取文件后，文件的指针会移动到当前读取的位置，例如在test.txt示例中，文件指针当前指向<strong>数据7</strong>，所以必须将文件指针回到文件的开头才能再次使用该文件，这里使用fseek()函数来修改文件的指针</p><ul><li><p>status = fseek(fid, offset, origin)</p><blockquote><p>参数：<br>fid：文件代号或文件句柄<br>offset：&gt;0 向文件末尾移动； =0 保持位置不变；  &lt;0 向文件开头移动<br>origin：文件位置指针移动的参考位置，<br> ‘bof’ 或 -1表示文件的开头；<br> ‘cof’或0表示文件的当前位置；<br> ‘eof’或1表示文件的末尾<br>返回值：<br>status=0表示改变指针位置成功，否则返回-1</p></blockquote></li><li><p>count = fprintf (fid, template, variable)</p><blockquote><p>参数：<br>fid：文件代号或文件句柄，当该项为空时，直接输出到屏幕中<br>template：输出文件的格式，与输入的格式描述相同，见上表-1<br>variable：要输出的变量<br>返回值：<br>count：按文件描述符格式划分的数据个数</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-5-9&lt;/p&gt;
&lt;h3 id=&quot;1-fopen、fprintf与fscanf的用法&quot;&gt;&lt;a href=&quot;#1-fopen、fprintf与fscanf的用法&quot; class=&quot;headerlink&quot; title=&quot;1. fopen、fprintf与fscanf的用法
      
    
    </summary>
    
      <category term="matlab" scheme="https://2033329616.github.io/categories/matlab/"/>
    
    
      <category term="fopen" scheme="https://2033329616.github.io/tags/fopen/"/>
    
      <category term="matlab" scheme="https://2033329616.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>linux系统安装及软件配置</title>
    <link href="https://2033329616.github.io/linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE.html"/>
    <id>https://2033329616.github.io/linux系统安装及软件配置.html</id>
    <published>2018-04-30T11:37:33.625Z</published>
    <updated>2018-04-30T13:34:50.039Z</updated>
    
    <content type="html"><![CDATA[<p>2017-11-29</p><h3 id="1-安装ubunut系统时一直卡在图标的位置无法进入安装界面"><a href="#1-安装ubunut系统时一直卡在图标的位置无法进入安装界面" class="headerlink" title="1.安装ubunut系统时一直卡在图标的位置无法进入安装界面"></a><strong>1.安装ubunut系统时一直卡在图标的位置无法进入安装界面</strong></h3><p>将系统bios里security boot设置为disable，重启后再重新进入安装状态；<br> 如果仍然无法进入安装状态：在选择安装和试用的界面，将光标移动到ubunt上，按 ‘e’，系统进入一个设置界面，在<code>quiet splash</code>后面加 <code>nomodeset</code>(别忘了空格)，然后按F10后系统以不设置显示模式的状态可以进入安装界面，但此时分辨率较低，尤其在选择分区后无法直接点击“安装”按钮，而且无法点击菜单栏拖动，此时使用<strong>alt + 鼠标左键</strong>可以拖动窗口，然后按步骤安装系统即可。</p><h3 id="2-电脑安装ubuntu16-04后重启一直黑屏无法进入系统"><a href="#2-电脑安装ubuntu16-04后重启一直黑屏无法进入系统" class="headerlink" title="2.电脑安装ubuntu16.04后重启一直黑屏无法进入系统"></a><strong>2.电脑安装ubuntu16.04后重启一直黑屏无法进入系统</strong></h3><p> 可能和电脑的intel核显卡和nvidia集成显卡的驱动有关，此时再以上面的nomodeset模式进入系统，使用指令<code>sudo apt-get install nvidia-current</code>，然后重启可以成功进入系统。<br>       如果没有进入系统又卡在黑屏界面，则使用另一种方法：<br>      1使用nomodeset模式进入系统，先安装Intel的核心显卡驱动，去官网下载update-tool工具，这是我下载的版本<code>intel-graphics-update-tool_2.0.2_amd64.deb</code>，然后安装即可。<br>    <code>sudo dpkg -i intel-graphics-update-tool_2.0.2_amd64.deb</code><br>    <code>sudo apt-get -f install</code><br>    <code>sudo apt-get update</code><br>安装完成后使用<code>glxinfo | grep rendering</code>可以查看安装的结果，显示yes表示安装成功<br>      2安装nvidia的显卡驱动<br>     <code>lspci | grep -i nvidia</code>查看电脑是否支持英伟达显卡，安装官网安装驱动<br>      a关闭图像界面和禁用nouveau<br>         进入字符界面<code>ctrl + alt + f1</code>后登录，<code>sudo serivce lightdm stop</code>关闭图像界面服务，禁用nouveau第三方驱动(步骤略)，<code>lsmod | nouveau</code>无输出则禁用成功<br>      b 安装nvidia的deb文件即可<br>     安装完成后使用<code>cat /proc/driver/nvidia/version</code>查看驱动版本，使用<code>nvidia-smi</code>也可以查看驱动及显卡的硬件信息<br> 所有的驱动安装完成后，重启进入系统，如果还没有进入系统，则按上述的办法重安nvidia驱动，使用<code>sudo apt-get remove nvidia</code>和<code>sudo /usr/bin/nvidia-uninstall</code>将驱动卸载干净再重新安装。</p><h3 id="3-配置sublime-python3的运行环境"><a href="#3-配置sublime-python3的运行环境" class="headerlink" title="3.配置sublime + python3的运行环境"></a><strong>3.配置sublime + python3的运行环境</strong></h3><h4 id="3-1-首先在ubuntu16-04下安装sublime-text3"><a href="#3-1-首先在ubuntu16-04下安装sublime-text3" class="headerlink" title="3.1 首先在ubuntu16.04下安装sublime text3"></a>3.1 首先在ubuntu16.04下安装sublime text3</h4><blockquote><p>sudo add-apt-repository ppa:webupd8team/sublime-text-3 添加apt的安装包来源<br>sudo apt-get update 更新软件源<br>sudo apt-get install sublime-text-installer 安装sublime text</p></blockquote><p> 安装完成后输入<code>subl 文件名</code>，如果该⽂件存在就会以sublime text打开， 否则就创建该⽂件， 默认的有代码<br>提⽰和⾼亮功能， 选择运⾏的环境后， Ctrl + B 可以编译运⾏编写的代码</p><p>PPA 全称为 Personal Package Archives（个⼈软件包档案） ,通常 PPA 源⾥的软件是官⽅源⾥没有的， 或<br>者是最新版本的软件。 相对于通过 Deb 包安装来说， 使⽤ PPA 的好处是， ⼀旦软件有更新， 通过<code>sudoapt-get upgrade</code> 这样命令就可以直接升级到新版本。<br>在 Ubuntu Karmic (9.10) 我们可以使⽤ <code>add-apt-repository</code> 脚本添加 ppa 到当前的库中并且⾃动导⼊<br>公钥。 在终端下使⽤语法： <code>add-apt-repository ppa:&lt;ppa_name&gt;</code></p><h4 id="3-2-配置python3环境"><a href="#3-2-配置python3环境" class="headerlink" title="3.2 配置python3环境"></a>3.2 配置python3环境</h4><p> A   新建运行环境使用Tools==&gt;Build System==&gt;New Build Systems生成一个配置文件，我们可以改   名字为python3.sublime-build，python3就成为了build system中的一个选项了，在该文件中写入：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"shell_cmd"</span>: <span class="string">"python3 -u \"<span class="variable">$file</span>\""</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">"selector"</span>: <span class="string">"source.python"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存后在build system中选择python3，使用<code>ctrl + B就</code>可以运行代码了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.version)</span><br><span class="line">print(sys.version_info)</span><br></pre></td></tr></table></figure></p><p>上面的代码可以输出使用的python版本，python2版本可以直接选择Tools==&gt;build system中的python就行，应为在系统中默认的是python2，所以这里要构建python3的运行环境。<br>B  在sublime中加入anaconda的插件，特别好使<br>先安装package control，然后安装anaconda的插件，点击Preferences==&gt;Package Settings==&gt;Anaconda==&gt;Settings User生成文件Anaconda.sublime-settings，里面写入下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;anaconda_linting&quot;: false,</span><br><span class="line"></span><br><span class="line">//保存文件后自动pep8格式化</span><br><span class="line"></span><br><span class="line">&quot;auto_formatting&quot;: true,</span><br><span class="line"></span><br><span class="line">&quot;enable_signatures_tooltip&quot;: false,</span><br><span class="line">// close the document in the function or packages</span><br><span class="line"></span><br><span class="line">&quot;python_interpreter&quot;: &quot;/usr/bin/python3&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置后，函数可以补全，可以查看定义等</p><h4 id="3-3-解决sublime无法输入中文问题"><a href="#3-3-解决sublime无法输入中文问题" class="headerlink" title="3.3 解决sublime无法输入中文问题"></a>3.3 解决sublime无法输入中文问题</h4><p><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code>  克隆项目到本地 </p><p><code>git clone https://github.com/lyfeyaj/sublime-text-imfix.git</code>  运行脚本<br><code>cd sublime-text-imfix &amp;&amp; ./sublime-imfix</code></p><p>最后重启即可<br>如果上述方法不可行，则：<br> 1将sublime-test-imfix/lib路径下的libsublime-imfix.so拷贝到sublime的文件夹下<br> 2 将sublime-test-imfix/src路径下的subl文件拷贝到/usr/bin/路径下并作修改如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">export LD_PRELOAD=/you_install_path/sublime_text/libsublime-imfix.so</span><br><span class="line">exec /you_install_path/sublime_text/sublime_text &quot;$@&quot;</span><br></pre></td></tr></table></figure></p><p>使用subl就可以打开sublime并输入中文了</p><h3 id="4-ubuntu安装vnc服务器"><a href="#4-ubuntu安装vnc服务器" class="headerlink" title="4.ubuntu安装vnc服务器"></a><strong>4.ubuntu安装vnc服务器</strong></h3><blockquote><p>sudo apt-get install tightvncserver 安装VNC服务器<br>tightvncserver 启动vnc服务器， 之后会要求输⼊密码， 任意输⼊密码（⼤于6个数）</p></blockquote><p>打开vnc viewer软件， 输⼊IP:n ,IP为vnc服务器的ip地址， n代表打开的窗⼝个数， 连接vnc服务器， 输⼊刚<br>才在服务器上的密码进⼊系统</p><h3 id="5-ubuntu安装ftp服务器"><a href="#5-ubuntu安装ftp服务器" class="headerlink" title="5.ubuntu安装ftp服务器"></a><strong>5.ubuntu安装ftp服务器</strong></h3><ol><li>⾸先服务器要安装ftp软件,查看是否已经安装ftp软件下：<br><code>sudo apt-get install vsftpd</code> 安装ftp软件<br><code>which vsftpd</code> 查看软件是否安装成功<br>如果看到有vsftpd的⽬录说明服务器已经安装了f tp软件</li></ol><ol><li><p>查看ftp 服务器状态<br><code>service vsftpd status</code> ,输出ftp服务器的状态</p></li><li><p>启动ftp服务器<br><code>service vsftpd start</code> 启动ftp服务器</p></li><li><p>重启ftp服务器<br><code>service vsftpd restart</code> 重启f tp服务器</p></li></ol><p>参考:<a href="http://blog.csdn.net/ft1512975/article/details/6620227" target="_blank" rel="noopener">http://blog.csdn.net/f t1512975/article/details/6620227</a></p><h3 id="6-ubuntu使用screen在ssh下查看历史历史窗口"><a href="#6-ubuntu使用screen在ssh下查看历史历史窗口" class="headerlink" title="6.ubuntu使用screen在ssh下查看历史历史窗口"></a><strong>6.ubuntu使用screen在ssh下查看历史历史窗口</strong></h3><p><code>sudo apt-get install screen</code> 安装该软件<br><code>screen</code> 开启一个新窗口，该窗口和普通的窗口功能一样<br>当我们在该窗⼝执⾏程序时， 当前screen窗⼝中键⼊<code>C-a d</code>，即Ctrl键+a键， 之后再按下d键,会退回到<br>screen前的窗⼝， 该命令的好处是虽然我们退出了ssh连接， 但是我们的程序任然在执⾏中， 我们可以⽤<br>ssh再次连接后， 使⽤ <code>top</code> 指令可以查看程序的运⾏状态， 但⽆法恢复之前的运⾏界⾯， ⽽screen可以做<br>到，<strong>监控窗口已关闭但依然在运行的程序，并调出该窗口</strong>。</p><blockquote><p>使⽤ screen -ls 列出screen窗⼝运⾏的数量， 每个窗⼝都有⾃⼰的编号，<br>使⽤ screen -r 窗⼝的编号 连接之前退出的screen窗⼝(该窗⼝的退出⽅式必须是 C-a d )<br>exit 可以退出当前的窗⼝， 并返回之前的窗⼝<br>C-a ? 显⽰所有键绑定信息<br>C-a w 显⽰所有窗⼝列表<br>C-a C-a 切换到之前显⽰的窗⼝<br>C-a c 创建⼀个新的运⾏shell的窗⼝并切换到该窗⼝<br>C-a n 切换到下⼀个窗⼝ C-a p 切换到前⼀个窗⼝(与C-a n相对) C-a 0..9 切换到窗⼝0..9 C-a a 发送<br>C-a到当前窗⼝ C-a d 暂时断开screen会话 C-a k 杀掉当前窗⼝ C-a进⼊拷贝/回滚模式</p></blockquote><p>参考：<a href="https://blog.csdn.net/wind19/article/details/4986458" target="_blank" rel="noopener">在ssh、telnet断开之后继续执行程序</a></p><h3 id="7-ubuntu以root身份打开文件管理器-GNOME"><a href="#7-ubuntu以root身份打开文件管理器-GNOME" class="headerlink" title="7.ubuntu以root身份打开文件管理器(GNOME)"></a><strong>7.ubuntu以root身份打开文件管理器(GNOME)</strong></h3><blockquote><p>sudo nautilus 以root用户打开文件管理器，可以在根目录的文件夹下进行操作</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017-11-29&lt;/p&gt;
&lt;h3 id=&quot;1-安装ubunut系统时一直卡在图标的位置无法进入安装界面&quot;&gt;&lt;a href=&quot;#1-安装ubunut系统时一直卡在图标的位置无法进入安装界面&quot; class=&quot;headerlink&quot; title=&quot;1.安装ubunut系统时一
      
    
    </summary>
    
      <category term="ubuntu系统" scheme="https://2033329616.github.io/categories/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="ubuntu系统" scheme="https://2033329616.github.io/tags/ubuntu%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="sublime配置" scheme="https://2033329616.github.io/tags/sublime%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>docker在ubuntu上的安装及使用</title>
    <link href="https://2033329616.github.io/docker%E5%9C%A8ubuntu%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.html"/>
    <id>https://2033329616.github.io/docker在ubuntu上的安装及使用.html</id>
    <published>2018-04-30T11:37:29.424Z</published>
    <updated>2018-04-30T13:59:13.613Z</updated>
    
    <content type="html"><![CDATA[<p>2018-3-30</p><h4 id="1-安装前的准备工作"><a href="#1-安装前的准备工作" class="headerlink" title="1.安装前的准备工作"></a><strong>1.安装前的准备工作</strong></h4><ol><li>确保是64位的操作系统</li><li>卸载旧版本的docker<br><code>sudo apt-get remove docker docker-engine docker.io</code><br>dockerde相关文件都在<code>/var/lib/docker/</code>路径下</li></ol><h4 id="2-使用docker仓库安装"><a href="#2-使用docker仓库安装" class="headerlink" title="2.使用docker仓库安装"></a><strong>2.使用docker仓库安装</strong></h4><blockquote><p><strong>首次安装docker时需要添加docker的仓库</strong></p></blockquote><ol><li>更新软件源的仓库信息<br><code>sudo apt-get update</code></li><li>安装包来使apt通过HTTPS来使用docker仓库<br><code>sudo apt-get install apt-transport-https ca-certificates \</code><br><code>curl software-properties-common</code>    </li><li>添加docker的官方GPG证书<br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg \</code><br><code>| sudo apt-key add -</code><ol><li>验证是否添加成功带有fingerprint的key<br><code>sudo apt-key fingerprint 0EBFCD88</code></li><li>添加稳定的docker仓库<br><code>sudo add-apt-repository \</code><br><code>&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</code><br><code>$(lsb_release -cs) stable&quot;</code><blockquote><p><strong>安装docker-ce</strong></p></blockquote></li></ol></li></ol><ol><li>再次更新仓库信息<br><code>sudo apt-get update</code></li><li>指令安装docker<br>注意:<code>sudo apt-get install docker-ce</code>只能安装目前最高的版本,但通常使用下面方法来选择要安装的版本<br><code>apt-cache madison docker-ce</code>查看目前的多个版本,结果如下:</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-30%2020-41-23.png" alt="目前docker-ce的版本" title="目前docker-ce的版本"><br> 使用<code>sudo apt-get install docker-ce=&lt;VERSION&gt;</code>安装特定的版本,这里使用17.12.0版本,指令为:<code>sudo apt-get install docker-ce=17.12.0~ce-0~ubuntu</code></p><ol><li>验证安装的结果<br>如果安装docker安装正确,则运行<code>sudo docker run hello-world</code>后输出下面结果:</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-30%2020-57-04.png" alt="docker安装成功" title="docker安装成功"></p><ul><li>其他详细的安装详情见官网 <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce-1" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce-1</a></li></ul><h4 id="4-创建docker组"><a href="#4-创建docker组" class="headerlink" title="4.创建docker组"></a><strong>4.创建docker组</strong></h4><blockquote><p>该操作的作用:不用每次使用docker指令时都输入sudo</p><ol><li>创建docker组<br><code>sudo groupadd docker</code>创建docker组<br><code>cat /etc/group | grep -i docker</code>查看docker组的基本情况如下,目前该组中还没有添加用户:</li></ol></blockquote><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-30%2021-31-44.png" alt="enter description here" title="docker组的信息"><br>2.为docker组添加用户<br><code>sudo usermod -aG docker $USER</code>,其中<code>$USER</code>表示当前的用户,再次查看docker用户组的信息如下,该组中多了个david用户(当前登录的用户):</p><ol><li>注销登录后,用户组生效,就可以直接使用不带sudo的docker指令</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-30%2021-34-55.png" alt="enter description here" title="david用户加入docker用户组"></p><h4 id="5-安装nvidia-docker来支持GPU"><a href="#5-安装nvidia-docker来支持GPU" class="headerlink" title="5.安装nvidia-docker来支持GPU"></a><strong>5.安装nvidia-docker来支持GPU</strong></h4><ol><li>卸载旧版本的nvidia-docker及GPU容器<br><code>docker volume ls -q -f driver=nvidia-docker |  \</code><br><code>xargs -r -I{} -n1 docker ps -q -a -f volume={} | \</code><br><code>xargs -r docker rm -f</code><br><code>sudo apt-get purge -y nvidia-docker</code></li><li>添加仓库<ul><li>添加key:<br><code>curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \sudo apt-key add -</code></li><li>获取系统版本号:<br><code>distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</code> </li><li>添加仓库:<br><code>curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \</code><br><code>sudo tee /etc/apt/sources.list.d/nvidia-docker.list</code> </li></ul><ol><li>更新仓库信息<br><code>sudo apt-get update</code></li></ol></li><li><p><strong>安装nvidia-docker2并配置docker dameon加速镜像下载</strong></p><ul><li>安装nvidia的gpu支持:<br><code>sudo apt-get install -y nvidia-docker2</code></li><li>修改<code>/etc/docker/daemon.json</code>文件内容如下:<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"http://58167a06.m.daocloud.io"</span>],</span><br><span class="line">  <span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="attr">"nvidia"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/nvidia-container-runtime"</span>,</span><br><span class="line">            <span class="attr">"runtimeArgs"</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>其中链接部分是使用国内的<strong>加速镜像</strong>,这里使用dalcloud的加速镜像,如果使用阿里云的加速镜像,将链接替换为<a href="https://8vntriz8.mirror.aliyuncs.com" target="_blank" rel="noopener">https://8vntriz8.mirror.aliyuncs.com</a>即可,该链接是在注册阿里开发者平台时生成的,具体的细节见<a href="https://www.cnblogs.com/atuotuo/p/6264800.html" target="_blank" rel="noopener">https://www.cnblogs.com/atuotuo/p/6264800.html</a>.</p><ul><li>重载daemon使配置生效,并重启docker:<br><code>sudo pkill -SIGHUP dockerd</code><br><code>sudo systemctl daemon-reload</code><br><code>sudo systemctl restart docker</code></li></ul></li><li><p>测试安装情况<br><code>docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</code>会下载cuda镜像来测试</p></li></ol><h4 id="5-使用docker安装tensorflow"><a href="#5-使用docker安装tensorflow" class="headerlink" title="5.使用docker安装tensorflow"></a><strong>5.使用docker安装tensorflow</strong></h4><ul><li>打开tensorflow的docker<a href="https://hub.docker.com/r/tensorflow/tensorflow/tags/" target="_blank" rel="noopener">镜像仓库</a>如下:</li></ul><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-31%2014-44-02.png" alt="tensorflow镜像" title="tensorflow的镜像"><br>使用指令<code>nvidia-docker run -it -p 8888:8888 tensorflow/tensorflow:&lt;mirror tag&gt;</code>下载并运行tag对应的镜像,这里使用tag为1.7.0-gpu-py3的镜像输出结果如下.</p><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-31%2014-53-50.png" alt="运行tensorflow的镜像" title="运行tensorflow的镜像"><br>将最下面的链接复制到浏览器就可以打开ipython notebook并使用对应的镜像环境了.</p><ul><li><p>注意:首次运行上面的指令会下载对应tag的镜像,之后运行可以直接从本地读取该镜像.</p></li><li><p>使用<code>docker images</code>查看已下载镜像信息,结果如下:</p></li></ul><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-31%2015-02-54.png" alt="enter description here" title="已下载的镜像信息"></p><ul><li>使用<code>docker rmi -f &lt;IMAGE ID&gt;</code> 删除对应ID号的镜像.</li></ul><h4 id="6-将主机的目录挂载到容器中"><a href="#6-将主机的目录挂载到容器中" class="headerlink" title="6.将主机的目录挂载到容器中"></a><strong>6.将主机的目录挂载到容器中</strong></h4><ol><li>首先使用<code>docker ps</code>查看目前运行的容器，结果如下，使用<code>docker kill &lt;container ID&gt;</code>关闭ID号对应的容器:</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-31%2023-04-59.png" alt="enter description here" title="查看目前运行的容器"></p><ol><li>使用<code>docker exec -it 2783ad1bf2dc /bin/bash</code>登录该容器,其中<code>2783ad1bf2dc</code>为第一步的结果中看到的容器ID号,登录的结果如下:</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-03-31%2023-16-41.png" alt="enter description here" title="容器的主目录结构"></p><blockquote><p>登录成功后,终端的用户和工作组组也随着改变,该容器的目录结构与一般的Linux相同,输入<code>exit</code>或使用按键<code>ctrl + d</code>退出登录状态.</p><p>OPTIONS说明：</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :标准输入,即使没有附加也保持STDIN 打开<ul><li>-t :分配一个伪终端,后面必须加<code>/bin/bash</code></li></ul></li></ul></blockquote><ol><li>这里将<code>/home/david/docker/tensorflow</code>目录挂载到1.7.0-gpu-py3容器的<code>/notebooks/tensorflow</code>目录下,将主机的目录挂载到容器后,修改主机的文件,容器中的文件也会同步更新,这样比较方便,操作如下:<br><code>docker run -it -v &lt;主机目录&gt;:&lt;容器挂载目录&gt; &lt;容器镜像&gt; /bin/bash</code>, <code>-v</code>表示挂载目录的选项;<strong>冒号</strong>前面是主机目录,后面是容器目录;最后面接容器镜像</li></ol><blockquote><p>这里的挂载目录操作:<br><code>docker run -it -v /home/david/docker/tensorflow:/notebooks/tensorflow tensorflow/tensorflow:1.7.0-gpu-py3 /bin/bash</code></p></blockquote><p>查看挂载结果如下:</p><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-04-01%2000-04-35.png" alt="enter description here" title="主机目录的挂载结果"><br>可以看出,在容器的<code>/notebooks</code>目录下已经出现了<code>tensorflow</code>目录,并且该文件夹下已经出现了在主机目录<code>/home/david/docker/tensorflow</code>里的<code>test.py</code>文件,即目录挂载成功.</p><blockquote><p><strong>注意:使用下面指令可以一步到位!打开ipython notebook并挂载主机目录到容器.</strong><br><code>docker run -it -v /home/david/docker/tensorflow:/notebooks/tensorflow -p 8888:8888 tensorflow/tensorflow:1.7.0-gpu-py3</code></p></blockquote><p>运行结果:</p><p><img src="http://p7jji9nvf.bkt.clouddn.com/Screenshot%20from%202018-04-01%2000-16-54.png" alt="enter description here" title="运行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-3-30&lt;/p&gt;
&lt;h4 id=&quot;1-安装前的准备工作&quot;&gt;&lt;a href=&quot;#1-安装前的准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.安装前的准备工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.安装前的准备工作&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;
&lt;l
      
    
    </summary>
    
      <category term="docker" scheme="https://2033329616.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://2033329616.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>dlib安装总结</title>
    <link href="https://2033329616.github.io/dlib%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93.html"/>
    <id>https://2033329616.github.io/dlib安装总结.html</id>
    <published>2018-04-21T14:00:43.866Z</published>
    <updated>2018-04-21T16:01:08.460Z</updated>
    
    <content type="html"><![CDATA[<p>2017-8-10</p><h3 id="1-dlib安装步骤"><a href="#1-dlib安装步骤" class="headerlink" title="1.dlib安装步骤"></a>1.dlib安装步骤</h3><p>ubuntu下最好别用anaconda，会出现很多问题，宁可自己安装各种包！</p><blockquote><p>sudo apt-get install build-essential cmake<br>sudo apt-get install libgtk-3-dev<br>sudo apt-get install libboost-all-dev<br>sudo apt-get install libopenblas-dev liblapack-dev  # 提高cpu处理速度</p><h1 id="pip-install-scikit-image"><a href="#pip-install-scikit-image" class="headerlink" title="pip install scikit-image"></a>pip install scikit-image</h1><p>sudo apt-get install python-skimage<br>pip install dlib</p></blockquote><p>如果pip安装失败，可以直接从pypi上下载安装包，离线安装！<br>如果dlib指令安装失败还可以编译源码，源码里使用<code>sudo python setup.py install</code>，就可以安装了，仅python的API，前提是setuptools已经安装完成。</p><h3 id="2-ubuntu16-06安装opencv3-3"><a href="#2-ubuntu16-06安装opencv3-3" class="headerlink" title="2.ubuntu16.06安装opencv3.3"></a>2.ubuntu16.06安装opencv3.3</h3><p>1.安装各种依赖库</p><blockquote><p>[compiler] <code>sudo apt-get install build-essential</code><br>[required] <code>sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</code><br>[optional] <code>sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</code></p></blockquote><p>2.下载源码后生成编译文件<br>2.1创建一个文件夹用来放cmake后的编译文件</p><blockquote><p>cd ~/opencv<br>mkdir build<br>cd build</p></blockquote><p>2.2cmake后创建make所需的文件</p><blockquote><p><code>cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..</code></p></blockquote><p>build文件夹下会产生makefile文件用于编译，cmake的编译选项还有其他的，但目前用上面的就够了，python的接口也包含进去了</p><p>3.编译源码产生对象文件(<strong>.o</strong>文件)</p><blockquote><p><code>make -j4</code> # j4表示开启4个线程<br><code>sudo make install</code> # 安装opencv库到系统中</p></blockquote><ol><li>配置opencv.conf file ，加入环境变量</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/error1.jpg" alt="enter description here" title="不进行此步骤出现的错误"></p><blockquote><p><code>sudo gedit /etc/ld.so.conf.d/opencv.conf</code></p><p>如果没有该文件，则上述的命令会创建该文件，在opencv.conf里面加入 <code>/usr/local/lib</code></p><h2 id="sudo-ldconfig-更新库目录"><a href="#sudo-ldconfig-更新库目录" class="headerlink" title="sudo ldconfig #更新库目录"></a><code>sudo ldconfig</code> #更新库目录</h2><p><a href="http://jingpin.jikexueyuan.com/article/36054.html" target="_blank" rel="noopener">Ubuntu 安装OpenCV3.0.0</a> blog里还有下述步骤：<br>打开文件<code>bash.bashrc</code><br><code>sudo gedit /etc/bash.bashrc</code></p><p>加入下面两行<br><code>PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</code><br><code>export PKG_CONFIG_PATH</code></p></blockquote><p>我这里进行测试，没有该步骤也行！</p><hr><p>5.测试opencv<br>5.1 C++版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">Mat src = imread(<span class="string">"test3.jpg"</span>,<span class="number">1</span>); </span><br><span class="line">imshow(<span class="string">"src"</span>,src);   </span><br><span class="line">waitKey(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>编译方式：<br>1 命令行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++  opencvtest.cpp -o opencvtest `pkg-config  --cflags --libs opencv`</span><br></pre></td></tr></table></figure></p><p>cflags前面是两个横线</p><p>2 借助cmake，写CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(opencvtest)</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">add_executable</span>( opencvtest opencvtest.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( opencvtest <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure><p>之后 执行</p><blockquote><p><code>cmake .</code><br><code>Make</code>   # 生成可执行文件<br><code>./ test</code> # 运行程序进行测试</p></blockquote><p>5.2python版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'test3.jpg'</span>,<span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p><code>python test.py</code> #运行该出现，会显示一张图片</p></blockquote><p>至此opencv的配置完成！</p><h3 id="3-virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头"><a href="#3-virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头" class="headerlink" title="3.virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头"></a>3.virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头</h3><blockquote><p><code>cheese</code>  #在ubuntu里可以打开摄像头</p></blockquote><p>  如果打不开，则需要设置virtualbox。<br>  1.首先去官网下载virtualbox的扩展包进行安装，如下图：</p><p>  <img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/virtualbox0.jpg" alt="enter description here" title="3.1 安装扩展包"></p><ol><li>然后设置虚拟机的usb选项，并勾选设备选项里的摄像头选项</li></ol><p><img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/virtualbox.jpg" alt="enter description here" title="3.2 设置usb控制器为usb2.0"></p><p> <img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/virtualbox2_1.jpg" alt="enter description here" title="3.3 勾选设备选项里的摄像头"></p><p>  设置好后再使用<code>cheese</code>指令打开摄像头，或运行与摄像头相关的程序，由于是虚拟机的原因摄像头比较卡。</p><h3 id="4-whl文件安装中的问题处理"><a href="#4-whl文件安装中的问题处理" class="headerlink" title="4.whl文件安装中的问题处理"></a>4.whl文件安装中的问题处理</h3><p> 原文件： <code>opencv_python-3.1.0-cp34-cp34m-win_amd64.whl</code>，<br>改后的文件：<code>opencv_python-3.1.0-cp34-none-win_amd64.whl</code><br> <strong>把原来文件名中间的cp34m变为none(其实不改也能安装成功)，并且cp34要和python的版本对应，如cp36表示python版本3.6，如果不改的话不然会出现下面的问题：(但只是更改版本号可能会带来兼容性问题)</strong></p><p>opencv_python-3.1.0-cp34-cp34m-win_amd64.whl is not a supported wheel on this platform.</p><blockquote><p>pip3 install 路径名\opencv_python-3.1.0-cp34-none-win_amd64.whl<br>安装该模块 </p></blockquote><h3 id="5-pip换源提升安装库的速度和稳定性"><a href="#5-pip换源提升安装库的速度和稳定性" class="headerlink" title="5. pip换源提升安装库的速度和稳定性"></a>5. <strong>pip换源提升安装库的速度和稳定性</strong></h3><p>网上有很多可用的源，<br>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a><br> 清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p> <code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名</code> 这样就会从清华这边的镜像去安装库。</p><p> 更改配置文件：<br>1.Linux系统<br>修改<code>~/.pip/pip.conf</code> (没有就创建一个)， 修改 index-url至tuna，内容如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><p>2.windows<br>直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件<strong>pip.ini</strong>，内容如下<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p>   <font color="red" face="宋体">进过不断的试错，总结如下：   1.首先为pip换源，这样大部分的库可以直接指令安装   2.换源后安装失败的，可以在[source1][7]和[source2][8]下载whl文件离线安装   3.大部分依赖库安装失败都是下载失败导致，所以上述两种方法可以解决大部分问题</font><p> <a href="http://blog.csdn.net/qw_xingzhe/article/details/52675158" target="_blank" rel="noopener">更改pip源至国内镜像，显著提升下载速度</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017-8-10&lt;/p&gt;
&lt;h3 id=&quot;1-dlib安装步骤&quot;&gt;&lt;a href=&quot;#1-dlib安装步骤&quot; class=&quot;headerlink&quot; title=&quot;1.dlib安装步骤&quot;&gt;&lt;/a&gt;1.dlib安装步骤&lt;/h3&gt;&lt;p&gt;ubuntu下最好别用anaconda，会
      
    
    </summary>
    
      <category term="Python" scheme="https://2033329616.github.io/categories/Python/"/>
    
      <category term="Opencv" scheme="https://2033329616.github.io/categories/Python/Opencv/"/>
    
    
      <category term="Python" scheme="https://2033329616.github.io/tags/Python/"/>
    
      <category term="dlib" scheme="https://2033329616.github.io/tags/dlib/"/>
    
      <category term="opencv" scheme="https://2033329616.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://2033329616.github.io/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://2033329616.github.io/C++学习笔记.html</id>
    <published>2018-04-21T06:33:57.761Z</published>
    <updated>2018-04-21T15:35:18.626Z</updated>
    
    <content type="html"><![CDATA[<p>2018-2-3</p><h3 id="1-C-的头文件和源文件"><a href="#1-C-的头文件和源文件" class="headerlink" title="1. C++的头文件和源文件"></a><strong>1. C++的头文件和源文件</strong></h3><p><code>.h</code>头文件只需预处理，<code>.cpp</code>才需要编译，一般在头文件里声明一个类及类的的方法，在源文件里实现函数的<strong>定义</strong>与<strong>实现</strong>，这样可以将声明和定义分开，利于构建大规模的程序。<br><code>hello.h</code>文件如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once       <span class="comment">//预编译一次，防止出现重复包含头文件的情况</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:                   <span class="comment">//共有函数及成员定义的关键词</span></span><br><span class="line">Hello();             <span class="comment">//声明构造函数，构造函数最好不要有默认参数</span></span><br><span class="line">~Hello();            <span class="comment">//声明析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(<span class="keyword">int</span> number=<span class="number">0</span>)</span></span>;    <span class="comment">//声明共有成员函数,参数给出默认值  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:            <span class="comment">//私有函数及成员定义的关键词</span></span><br><span class="line"><span class="built_in">string</span> content; <span class="comment">//声明一个字符串变量</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>hello.cpp</code>文件如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的定义与实现</span></span><br><span class="line">Hello::Hello()      <span class="comment">//构造函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">content = <span class="string">"这是私有成员变量"</span>;      <span class="comment">//在构造函数中为成员变量赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"这是构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Hello::~Hello()       <span class="comment">//析构函数定义</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"这是析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Hello::talk(<span class="keyword">int</span> number)    <span class="comment">//成员函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">num = number;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"content:"</span>&lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//头文件中包含了string才能使用该句</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"num:"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主函数main.cpp如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Hello robot;      <span class="comment">//实例化一个对象</span></span><br><span class="line">robot.talk(<span class="number">233</span>);  <span class="comment">//调用成员函数，默认参数为0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><p><img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/result.jpg" alt="enter description here" title="运行结果"></p><h3 id="2-C-中的L和-T的作用"><a href="#2-C-中的L和-T的作用" class="headerlink" title="2. C++中的L和_T的作用"></a><strong>2. C++中的L和_T的作用</strong></h3><p>在一个字符串前加 <code>L</code>表示将ANSI字符串转换为unicode的字符串，每个字符占两个字节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(<span class="string">"abc"</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">strlen</span>(<span class="string">L"asd"</span>) = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><p> _T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式，如果你定义了UNICODE，那么_T宏会把字符串前面加一个L。这时 _T(“ABCD”) 相当于 L”ABCD” ，这是宽字符串。如果没有定义，那么_T宏不会在字符串前面加那个L，_T(“ABCD”) 就等价于 “ABCD”  </p><h3 id="3-C-调用Python函数的方法"><a href="#3-C-调用Python函数的方法" class="headerlink" title="3. C++调用Python函数的方法"></a><strong>3. C++调用Python函数的方法</strong></h3><p> 这里使用vs2015编译程序，首先要设置项目的属性，把python的include目录和libs目录包含到项目中，设置如下：</p><p> <img src="http://p7jji9nvf.bkt.clouddn.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/c++%E8%B0%83%E7%94%A8python_3.jpg" alt="enter description here" title="项目的属性设置"></p><p> python程序如下：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertStrToNum</span><span class="params">(string)</span>:</span></span><br><span class="line">result = eval(string)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p> 这里的python程序当做模块来对待，文件夹名称为strToNum，文件名strToNum.py，在同一个文件夹下有<strong>init</strong>.py文件(内容可为空)来表示模块。</p><p> 在<code>C++</code>程序中调用python函数时注意：python语句写成模块的形式；将python模块的路径添加到系统中，否则c++程序无法找到python模块，最好使用相对路径；</p><p> 步骤：<br> 1.<code>Py_Initialize()</code>初始化python;<br> 2.定义PyObject相关指针，</p><ul><li>载入python模块</li><li>加载模块函数</li><li>添加参数列表</li><li>调用python函数</li><li>定义C++数据变量，转换python返回的参数为<code>C++</code>的数据类型，并用该变量接收</li></ul><p>3.<code>Py_Finalize()</code>释放资源</p><p> c++程序如下<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Python.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstring"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Py_Initialize();</span><br><span class="line"><span class="comment">//PyRun_SimpleString("x=eval('2 + 3*2')");    //运行单个python语句</span></span><br><span class="line"><span class="comment">//PyRun_SimpleString("print(x)");</span></span><br><span class="line"><span class="comment">//PyArg_Parse(x, "i");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Python工作路径切换到待调用模块所在目录，一定要保证路径名的正确性</span></span><br><span class="line"><span class="built_in">string</span> path = <span class="string">".\\strToNum"</span>;                  <span class="comment">//相对路径，windows下</span></span><br><span class="line"><span class="built_in">string</span> chdir_cmd = <span class="built_in">string</span>(<span class="string">"sys.path.append(\""</span>) + path + <span class="string">"\")"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr_cmd = chdir_cmd.c_str();</span><br><span class="line">PyRun_SimpleString(<span class="string">"import sys"</span>);</span><br><span class="line">PyRun_SimpleString(cstr_cmd);</span><br><span class="line">PyRun_SimpleString(<span class="string">"import os"</span>);</span><br><span class="line">PyRun_SimpleString(<span class="string">"print(os.getcwd())"</span>);    <span class="comment">//获取当前路径</span></span><br><span class="line">PyRun_SimpleString(<span class="string">"print(sys.path)"</span>);</span><br><span class="line"></span><br><span class="line">PyObject *pModule = <span class="literal">NULL</span>;       <span class="comment">//接收python模块</span></span><br><span class="line">PyObject *pFunc = <span class="literal">NULL</span>;         <span class="comment">//接收pyhton函数</span></span><br><span class="line">PyObject *pResult = <span class="literal">NULL</span>;       <span class="comment">//接收python函数的返回结果</span></span><br><span class="line"><span class="keyword">double</span> result = <span class="number">0</span>;              <span class="comment">//C++中接收最终计算结果的变量</span></span><br><span class="line"></span><br><span class="line">pModule = PyImport_ImportModule(<span class="string">"strToNum"</span>);</span><br><span class="line"><span class="keyword">if</span> (!pModule) <span class="comment">// 加载模块失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ERROR] Python get module failed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[INFO] Python get module succeed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">pFunc = PyObject_GetAttrString(pModule, <span class="string">"convertStrToNum"</span>);</span><br><span class="line"><span class="keyword">if</span> (!pFunc || !PyCallable_Check(pFunc))  <span class="comment">// 验证是否加载成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ERROR] Can't find funftion (convertStrToNum)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[INFO] Get function (convertStrToNum) succeed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">PyObject *pArgs = PyTuple_New(<span class="number">1</span>);         <span class="comment">//新建数组保存传入python函数的参数</span></span><br><span class="line">PyTuple_SetItem(pArgs, <span class="number">0</span>, Py_BuildValue(<span class="string">"s"</span>, <span class="string">"1 + 2*4.3 -1"</span>));</span><br><span class="line"><span class="comment">//PyObject *pArgs = Py_BuildValue("23");</span></span><br><span class="line">pResult = PyEval_CallObject(pFunc, pArgs);  <span class="comment">//调用python函数</span></span><br><span class="line">PyArg_Parse(pResult, <span class="string">"d"</span>, &amp;result);         <span class="comment">//python函数的返回结果转换为double</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"result:"</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Py_Finalize();      <span class="comment">//释放资源</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 参考的文章：<br> <a href="http://blog.csdn.net/itbuluoge/article/details/13005369" target="_blank" rel="noopener"><code>C++</code>调用python返回值</a><br> <a href="http://blog.csdn.net/nynyvkhhiiii/article/details/17525865" target="_blank" rel="noopener">调用python的类函数</a><br> <a href="https://docs.microsoft.com/zh-cn/visualstudio/python/working-with-c-cpp-python-in-visual-studio" target="_blank" rel="noopener">使用与pyhton的<code>C++</code>扩展</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-2-3&lt;/p&gt;
&lt;h3 id=&quot;1-C-的头文件和源文件&quot;&gt;&lt;a href=&quot;#1-C-的头文件和源文件&quot; class=&quot;headerlink&quot; title=&quot;1. C++的头文件和源文件&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. C++的头文件和源文件&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="C++" scheme="https://2033329616.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://2033329616.github.io/tags/C/"/>
    
      <category term="C++调用Python" scheme="https://2033329616.github.io/tags/C-%E8%B0%83%E7%94%A8Python/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记(1)</title>
    <link href="https://2033329616.github.io/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://2033329616.github.io/python学习笔记.html</id>
    <published>2018-04-20T12:49:59.065Z</published>
    <updated>2018-06-29T14:33:09.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-python里args和-kwargs的用法"><a href="#1-python里args和-kwargs的用法" class="headerlink" title="1. python里args和*kwargs的用法"></a>1. python里<em>args和*</em>kwargs的用法</h3><p><code>引入参数*args和**kwargs，两个都是python中的可变参数。*args表示任何多个无名参数，它是一个tuple</code><br><code>**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'args = '</span>, args</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'kwargs = '</span>, kwargs</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'---------------------------------------'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)                             <span class="comment">#参数只传到*args中</span></span><br><span class="line">    foo(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>)                         <span class="comment">#参数只传到**kwargs中</span></span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>)                <span class="comment">#参数可以传到*args和**kwargs中</span></span><br><span class="line">    foo(<span class="string">'a'</span>, <span class="number">1</span>, <span class="keyword">None</span>, a=<span class="number">1</span>, b=<span class="string">'2'</span>, c=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">args =  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kwargs =  &#123;&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line">args =  ()</span><br><span class="line">kwargs =  &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line">args =  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kwargs =  &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line">args =  (<span class="string">'a'</span>, <span class="number">1</span>, <span class="keyword">None</span>)</span><br><span class="line">kwargs =  &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="string">'2'</span>&#125;</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure></p><h3 id="2-python对txt文件的操作"><a href="#2-python对txt文件的操作" class="headerlink" title="2.python对txt文件的操作"></a>2.python对txt文件的操作</h3><p>2.1 使用<strong>open()</strong> 函数读取文本内容，本函数是打开一个文件并返回文件对象。如果文件不能打开，抛出异常OSError<br><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=T)</code><br>参数mode是指明打开文件的模式。默认值是’r’，表示使用文本的方式打开文件来读取。</p><p>‘r’表示打开文件只读，不能写。</p><p>‘w’表示打开文件只写，并且清空文件。</p><p>‘x’表示独占打开文件，如果文件已经存打开就会失败。</p><p>‘a’表示打开文件写，不清空文件，在文件后尾追加的方式写入。</p><p>‘b’表示二进制的模式打开文件。</p><p>‘t’表示文本模式，默认情况下就是这种模式。</p><p>‘+’打开文件更新（读取或写入）。</p><p>缺省时的模式就相当于’rt’。比如’w+b’就是打开文件进入读写，把文件清空；’r+b’打开文件，但不把文件清空<br>打开文件的操作常使用异常捕捉来</p><p>str.strip(rm)方法,去除字符串开头和结尾的rm字符，<code>readline()</code>获取的是一行文本的字符串形式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""打开一个文件，存储到列表中，并返回该列表"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_open:    <span class="comment">#打开文件，因为只有一行，所以不用使用循环</span></span><br><span class="line">            data = file_open.readline()</span><br><span class="line">        <span class="comment"># [james,james2,james3] = data.strip().split(',', 2)          #方法串链，从左向右作用</span></span><br><span class="line">        file_data = data.strip().split(<span class="string">','</span>)</span><br><span class="line">        <span class="string">"""split方法返回字符串列表，如果只是一个标识符接受，则不会报错</span></span><br><span class="line"><span class="string">        如果是[list1,list2,...]的形式则有可能因为接受数据的列表元素个数，与返回的</span></span><br><span class="line"><span class="string">        字符串列表的个数不一致而导致ValueError"""</span></span><br><span class="line">        <span class="keyword">return</span> file_data</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> ioerr:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'IOError:'</span> + str(ioerr)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> valerr:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ValueError:'</span> + str(valerr)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p> <code>(role, line_spoken) = each_line.split(&#39; ,&#39;)</code>，多重赋值(),[]均可以接受数据-字符串列表，<strong>each_line本身不会被分割，保持不变</strong><br><code>[role, line_spoken] = each_line.split(&#39;, &#39;,1)</code><br><code>[string1, string2, string3] = each_line.split(&#39;, &#39;, 2)</code>如果分割后的字符首位有“空格”，也会把其当成字符串第二个参数表示使用的分割符的个数，使用1则分为两个部分，如果不加则表示只要存在分隔符就会分解,n个分隔符分为n+1个部分，空字符也算入被分割的部分</p><p>2.2 使用<strong>open()</strong> 函数和<strong>file_object.write()</strong> 方法写入文本<br><strong>方法一、增加额外的逻辑来处理异常</strong>,使用finally来关闭文件对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:   <span class="comment">#文件写入过程</span></span><br><span class="line">    man_file = open(<span class="string">'man_data.txt'</span>, <span class="string">'w'</span>)         <span class="comment">#新建文件</span></span><br><span class="line">    other_file = open(<span class="string">'other_data.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    <span class="string">""" write()与print都可以写入数据，当print可以由字符串或列表写入，</span></span><br><span class="line"><span class="string">    write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里"""</span></span><br><span class="line">    <span class="comment"># print &gt;&gt; man_file, man                       #文件对象里传入数据</span></span><br><span class="line">    <span class="comment"># print &gt;&gt; other_file, other</span></span><br><span class="line">    man_file.write(str(man))</span><br><span class="line">    other_file.write(str(other))</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'File error.'</span></span><br><span class="line"><span class="keyword">finally</span>:  <span class="comment">#无论有无异常，此句都会执行，</span></span><br><span class="line">    man_file.close()</span><br><span class="line">    other_file.close()</span><br></pre></td></tr></table></figure></p><p><strong>方法二、with处理文件异常</strong>,不用考虑关闭文件对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:   <span class="comment">#文件写入过程</span></span><br><span class="line">    <span class="comment"># with open('man_data.txt', 'w') as man_file:         #新建文件</span></span><br><span class="line">    <span class="comment">#     # print &gt;&gt; man_file, man                        #文件对象里传入数据</span></span><br><span class="line">    <span class="comment">#     man_file.write(str(man))</span></span><br><span class="line">    <span class="comment"># with open('other_data.txt', 'w') as other_file:</span></span><br><span class="line">    <span class="comment">#     """ write()与print都可以写入数据，当print可以由字符串或列表写入，</span></span><br><span class="line">    <span class="comment">#          write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里"""</span></span><br><span class="line">    <span class="comment">#     # print &gt;&gt; other_file, other</span></span><br><span class="line">    <span class="comment">#     other_file.write(str(other))</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'man_data.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> man_file, open(<span class="string">'other_data.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> other_file:</span><br><span class="line">        <span class="comment">#两个语句合并为一个with语句</span></span><br><span class="line">        man_file.write(str(man))</span><br><span class="line">        other_file.write(str(other))</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'File error:'</span> + str(err)</span><br></pre></td></tr></table></figure></p><p>2.3实例<br>打开train_data.txt，读取其中的前四行，然后存储到train_data2.txt文件里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="comment"># file.readlines()读取数据的行数，'行数据\n' 是该方法输出列表的每行数据的元素</span></span><br><span class="line">attribute_data = []</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./train_data.txt'</span>) <span class="keyword">as</span> file,  open(<span class="string">'./train_data2.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> file2:</span><br><span class="line">raw_number = len(file.readlines())      <span class="comment"># 计算文件的总行数</span></span><br><span class="line">file.seek(<span class="number">0</span>)                            <span class="comment"># 回到第一行，因为每次使用readline，文本都会后退一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(raw_number):        <span class="comment"># 计算文件的总行数，设计循环逐行读入数据</span></span><br><span class="line">text_line = file.readline()     <span class="comment"># 每次调用该函数使文件下移一行</span></span><br><span class="line"><span class="comment"># temp_file = text_line.strip().split(' ', 32)              # temp_file存储分割后的数据列表</span></span><br><span class="line"><span class="comment"># attribute_data = temp_file[0:2] + temp_file[12:32]        # 存储要使用的数据列</span></span><br><span class="line">temp_file = text_line.strip().split(<span class="string">' '</span>, <span class="number">4</span>)             <span class="comment"># temp_file存储分割后的数据列表</span></span><br><span class="line">attribute_data = temp_file[<span class="number">0</span>:<span class="number">4</span>]      <span class="comment"># 存储要使用的数据列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> attribute_data:          <span class="comment"># 逐行写入数据,只能每个字符分别读入，才可以在数据中间插入空格</span></span><br><span class="line">file2.writelines(data)</span><br><span class="line">file2.writelines(<span class="string">' '</span>)            <span class="comment"># 数据间加入空格</span></span><br><span class="line">file2.writelines(<span class="string">'\n'</span>)               <span class="comment"># 数据换行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'File error:'</span> + str(err)</span><br><span class="line"><span class="keyword">print</span> attribute_data </span><br><span class="line">`</span><br></pre></td></tr></table></figure><h3 id="3-python函数shutil，实现文件的复制"><a href="#3-python函数shutil，实现文件的复制" class="headerlink" title="3.python函数shutil，实现文件的复制"></a>3.python函数shutil，实现文件的复制</h3><p>使用<code>shutil.copy(str_file1,str_file2)</code>将文件str_file1，复制到文件str_file2的位置</p><h3 id="4-python实现读取文件夹里文件名功能"><a href="#4-python实现读取文件夹里文件名功能" class="headerlink" title="4.python实现读取文件夹里文件名功能"></a>4.python实现读取文件夹里文件名功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">path = <span class="string">'the path of the directory'</span>    <span class="comment"># 读取文件路径</span></span><br><span class="line">list_name = os.listdir(path)            <span class="comment"># 读取路径下文件和文件夹的名</span></span><br></pre></td></tr></table></figure><p>则list_name就是文件夹里所以子文件夹和文件的列表，可以通过os.path.isfile和os.path.isdir来对列表里的项进行判断看是文件还是文件夹。</p><h3 id="5-python新建字典"><a href="#5-python新建字典" class="headerlink" title="5.python新建字典"></a>5.python新建字典</h3><ol><li>使用最基础的{ }方法</li><li>使用dict()将元素为二元组的列表转换为字典</li><li>使用参数赋值法dict(a=1)方式来创建字典，不过key只能为字符即dict(1=3,’1’=4)不行</li><li>使用zip处理两个列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="string">'b'</span>&#125;</span><br><span class="line">print(a)</span><br><span class="line">b  = dict([(<span class="string">'a'</span>,<span class="string">'b'</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="string">'c'</span>)])</span><br><span class="line">print(b)</span><br><span class="line">c = dict(a=<span class="number">1</span>, b=<span class="number">3</span>)</span><br><span class="line">print(c)</span><br><span class="line">d = dict(zip(<span class="string">'abc'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">print(d)</span><br><span class="line">e = dict(zip([<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'b'</span>], [<span class="number">2</span>, <span class="string">'c'</span>, <span class="number">3</span>]))</span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="string">'b'</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'b'</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="string">'c'</span>, <span class="string">'b'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类似于列表生成的方法生成字典</span></span><br><span class="line">l = dict((k, v) <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]))</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-python里args和-kwargs的用法&quot;&gt;&lt;a href=&quot;#1-python里args和-kwargs的用法&quot; class=&quot;headerlink&quot; title=&quot;1. python里args和*kwargs的用法&quot;&gt;&lt;/a&gt;1. python里&lt;em
      
    
    </summary>
    
      <category term="Python" scheme="https://2033329616.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://2033329616.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
