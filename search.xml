<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++学习笔记]]></title>
    <url>%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[2018-2-3 1. C++的头文件和源文件.h头文件只需预处理，.cpp才需要编译，一般在头文件里声明一个类及类的的方法，在源文件里实现函数的定义与实现，这样可以将声明和定义分开，利于构建大规模的程序。hello.h文件如下：12345678910111213141516#pragma once //预编译一次，防止出现重复包含头文件的情况#include "iostream"#include "string"using namespace std;class Hello&#123;public: //共有函数及成员定义的关键词 Hello(); //声明构造函数，构造函数最好不要有默认参数 ~Hello(); //声明析构函数 void talk(int number=0); //声明共有成员函数,参数给出默认值 private: //私有函数及成员定义的关键词 string content; //声明一个字符串变量 int num;&#125;; hello.cpp文件如下：12345678910111213141516171819#include "hello.h"//类的定义与实现Hello::Hello() //构造函数定义&#123; content = "这是私有成员变量"; //在构造函数中为成员变量赋值 cout &lt;&lt; "这是构造函数" &lt;&lt; endl;&#125;Hello::~Hello() //析构函数定义&#123; cout &lt;&lt; "这是析构函数" &lt;&lt; endl;&#125;void Hello::talk(int number) //成员函数定义&#123; num = number; cout &lt;&lt;"content:"&lt;&lt; content &lt;&lt; endl; //头文件中包含了string才能使用该句 cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;&#125; 主函数main.cpp如下：12345678910#include "iostream"#include "hello.h"using namespace std;int main()&#123; Hello robot; //实例化一个对象 robot.talk(233); //调用成员函数，默认参数为0 return 0;&#125; 运行结果如下： 2. C++中的L和_T的作用在一个字符串前加 L表示将ANSI字符串转换为unicode的字符串，每个字符占两个字节12strlen("abc") = 3;strlen(L"asd") = 6; _T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式，如果你定义了UNICODE，那么_T宏会把字符串前面加一个L。这时 _T(“ABCD”) 相当于 L”ABCD” ，这是宽字符串。如果没有定义，那么_T宏不会在字符串前面加那个L，_T(“ABCD”) 就等价于 “ABCD” 3. C++调用Python函数的方法 这里使用vs2015编译程序，首先要设置项目的属性，把python的include目录和libs目录包含到项目中，设置如下： python程序如下： 1234 # pythondef convertStrToNum(string): result = eval(string) return result 这里的python程序当做模块来对待，文件夹名称为strToNum，文件名strToNum.py，在同一个文件夹下有init.py文件(内容可为空)来表示模块。 在C++程序中调用python函数时注意：python语句写成模块的形式；将python模块的路径添加到系统中，否则c++程序无法找到python模块，最好使用相对路径； 步骤： 1.Py_Initialize()初始化python; 2.定义PyObject相关指针， 载入python模块 加载模块函数 添加参数列表 调用python函数 定义C++数据变量，转换python返回的参数为C++的数据类型，并用该变量接收 3.Py_Finalize()释放资源 c++程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 #include "iostream"#include "Python.h"#include "string"#include "cstring"using namespace std;int main()&#123; Py_Initialize(); //PyRun_SimpleString("x=eval('2 + 3*2')"); //运行单个python语句 //PyRun_SimpleString("print(x)"); //PyArg_Parse(x, "i"); // 将Python工作路径切换到待调用模块所在目录，一定要保证路径名的正确性 string path = ".\\strToNum"; //相对路径，windows下 string chdir_cmd = string("sys.path.append(\"") + path + "\")"; const char* cstr_cmd = chdir_cmd.c_str(); PyRun_SimpleString("import sys"); PyRun_SimpleString(cstr_cmd); PyRun_SimpleString("import os"); PyRun_SimpleString("print(os.getcwd())"); //获取当前路径 PyRun_SimpleString("print(sys.path)"); PyObject *pModule = NULL; //接收python模块 PyObject *pFunc = NULL; //接收pyhton函数 PyObject *pResult = NULL; //接收python函数的返回结果 double result = 0; //C++中接收最终计算结果的变量 pModule = PyImport_ImportModule("strToNum"); if (!pModule) // 加载模块失败 &#123; cout &lt;&lt; "[ERROR] Python get module failed." &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Python get module succeed." &lt;&lt; endl; pFunc = PyObject_GetAttrString(pModule, "convertStrToNum"); if (!pFunc || !PyCallable_Check(pFunc)) // 验证是否加载成功 &#123; cout &lt;&lt; "[ERROR] Can't find funftion (convertStrToNum)" &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Get function (convertStrToNum) succeed." &lt;&lt; endl; PyObject *pArgs = PyTuple_New(1); //新建数组保存传入python函数的参数 PyTuple_SetItem(pArgs, 0, Py_BuildValue("s", "1 + 2*4.3 -1")); //PyObject *pArgs = Py_BuildValue("23"); pResult = PyEval_CallObject(pFunc, pArgs); //调用python函数 PyArg_Parse(pResult, "d", &amp;result); //python函数的返回结果转换为double cout &lt;&lt; "result:" &lt;&lt; result &lt;&lt; endl; Py_Finalize(); //释放资源 return 0;&#125; 参考的文章： C++调用python返回值 调用python的类函数 使用与pyhton的C++扩展]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++调用Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[1. python里*args和**kwargs的用法引入参数*args和**kwargs，两个都是python中的可变参数。*args表示任何多个无名参数，它是一个tuple**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前12345678910def foo(*args, **kwargs): print 'args = ', args print 'kwargs = ', kwargs print '---------------------------------------'if __name__ == '__main__': foo(1,2,3,4) #参数只传到*args中 foo(a=1,b=2,c=3) #参数只传到**kwargs中 foo(1,2,3,4, a=1,b=2,c=3) #参数可以传到*args和**kwargs中 foo('a', 1, None, a=1, b='2', c=3) 运行结果：123456789101112args = (1, 2, 3, 4)kwargs = &#123;&#125;---------------------------------------args = ()kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = (1, 2, 3, 4)kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = ('a', 1, None)kwargs = &#123;'a': 1, 'c': 3, 'b': '2'&#125;--------------------------------------- 2.python对txt文件的操作2.1 使用open() 函数读取文本内容，本函数是打开一个文件并返回文件对象。如果文件不能打开，抛出异常OSErroropen(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=T)参数mode是指明打开文件的模式。默认值是’r’，表示使用文本的方式打开文件来读取。 ‘r’表示打开文件只读，不能写。 ‘w’表示打开文件只写，并且清空文件。 ‘x’表示独占打开文件，如果文件已经存打开就会失败。 ‘a’表示打开文件写，不清空文件，在文件后尾追加的方式写入。 ‘b’表示二进制的模式打开文件。 ‘t’表示文本模式，默认情况下就是这种模式。 ‘+’打开文件更新（读取或写入）。 缺省时的模式就相当于’rt’。比如’w+b’就是打开文件进入读写，把文件清空；’r+b’打开文件，但不把文件清空打开文件的操作常使用异常捕捉来 str.strip(rm)方法,去除字符串开头和结尾的rm字符，readline()获取的是一行文本的字符串形式1234567891011121314151617def open_file(filename): """打开一个文件，存储到列表中，并返回该列表""" try: with open(filename) as file_open: #打开文件，因为只有一行，所以不用使用循环 data = file_open.readline() # [james,james2,james3] = data.strip().split(',', 2) #方法串链，从左向右作用 file_data = data.strip().split(',') """split方法返回字符串列表，如果只是一个标识符接受，则不会报错 如果是[list1,list2,...]的形式则有可能因为接受数据的列表元素个数，与返回的 字符串列表的个数不一致而导致ValueError""" return file_data except IOError as ioerr: print 'IOError:' + str(ioerr) return None except ValueError as valerr: print 'ValueError:' + str(valerr) return None (role, line_spoken) = each_line.split(&#39; ,&#39;)，多重赋值(),[]均可以接受数据-字符串列表，each_line本身不会被分割，保持不变[role, line_spoken] = each_line.split(&#39;, &#39;,1)[string1, string2, string3] = each_line.split(&#39;, &#39;, 2)如果分割后的字符首位有“空格”，也会把其当成字符串第二个参数表示使用的分割符的个数，使用1则分为两个部分，如果不加则表示只要存在分隔符就会分解,n个分隔符分为n+1个部分，空字符也算入被分割的部分 2.2 使用open() 函数和file_object.write() 方法写入文本方法一、增加额外的逻辑来处理异常,使用finally来关闭文件对象1234567891011121314try: #文件写入过程 man_file = open('man_data.txt', 'w') #新建文件 other_file = open('other_data.txt', 'w') """ write()与print都可以写入数据，当print可以由字符串或列表写入， write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # print &gt;&gt; man_file, man #文件对象里传入数据 # print &gt;&gt; other_file, other man_file.write(str(man)) other_file.write(str(other))except IOError: print 'File error.'finally: #无论有无异常，此句都会执行， man_file.close() other_file.close() 方法二、with处理文件异常,不用考虑关闭文件对象123456789101112131415try: #文件写入过程 # with open('man_data.txt', 'w') as man_file: #新建文件 # # print &gt;&gt; man_file, man #文件对象里传入数据 # man_file.write(str(man)) # with open('other_data.txt', 'w') as other_file: # """ write()与print都可以写入数据，当print可以由字符串或列表写入， # write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # # print &gt;&gt; other_file, other # other_file.write(str(other)) with open('man_data.txt', 'w') as man_file, open('other_data.txt', 'w') as other_file: #两个语句合并为一个with语句 man_file.write(str(man)) other_file.write(str(other))except IOError as err: print 'File error:' + str(err) 2.3实例打开train_data.txt，读取其中的前四行，然后存储到train_data2.txt文件里 1234567891011121314151617181920212223# encoding:utf-8# file.readlines()读取数据的行数，'行数据\n' 是该方法输出列表的每行数据的元素attribute_data = []try: with open('./train_data.txt') as file, open('./train_data2.txt','w') as file2: raw_number = len(file.readlines()) # 计算文件的总行数 file.seek(0) # 回到第一行，因为每次使用readline，文本都会后退一行 for i in range(raw_number): # 计算文件的总行数，设计循环逐行读入数据 text_line = file.readline() # 每次调用该函数使文件下移一行 # temp_file = text_line.strip().split(' ', 32) # temp_file存储分割后的数据列表 # attribute_data = temp_file[0:2] + temp_file[12:32] # 存储要使用的数据列 temp_file = text_line.strip().split(' ', 4) # temp_file存储分割后的数据列表 attribute_data = temp_file[0:4] # 存储要使用的数据列 for data in attribute_data: # 逐行写入数据,只能每个字符分别读入，才可以在数据中间插入空格 file2.writelines(data) file2.writelines(' ') # 数据间加入空格 file2.writelines('\n') # 数据换行except IOError as err: print 'File error:' + str(err)print attribute_data ` 3.python函数shutil，实现文件的复制使用shutil.copy(str_file1,str_file2)将文件str_file1，复制到文件str_file2的位置 4.python实现读取文件夹里文件名功能123import os path = 'the path of the directory' # 读取文件路径list_name = os.listdir(path) # 读取路径下文件和文件夹的名 则list_name就是文件夹里所以子文件夹和文件的列表，可以通过os.path.isfile和os.path.isdir来对列表里的项进行判断看是文件还是文件夹。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
