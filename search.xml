<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[日积月累1]]></title>
    <url>%2F%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF.html</url>
    <content type="text"><![CDATA[2018-6-15 1. 条件随机场(CRF)&ensp;&ensp;特征函数仅使用当前单词和它前一个单词的标签对标注序列进行评价，这类CRF是最简单的线性链CRF 首先定义特征函数集合，该函数以整个句子s、当前位置i、位置i和i-1的标签为输入 为每个特征函数赋予一个权重 对每个标注序列I，对所有的特征函数加权求和，而且可以将求和的结果经过softmax处理转换为概率值评价函数为 \sum_{i=1}^m\sum_{i=1}^n\lambda_jf_j(s,i,l_i,l_i-1) &ensp;&ensp;其中$\lambda_j$是第j个特征函数的权重，$f_j$是第j个特征函数，这里共m个特征函数，s表示句子，i表示句子中的第i个单词，$l_i$表示第l个标注序列给第i个单词标注的词性，$l_{i-1}$标注的第i-1个单词。外面的求和用来将所有特征函数的得分求和；里面的求和号用来将句子中每个单词的得分求和，对这个得分进行softmax得到每个标注序列的得分概率，公式如下 p(l|s) = \frac{exp[score(l|s)]}{\sum_{l^`}exp[score(l^`|s)]} 逻辑回归是用于分类的对数线性模型；条件随机场是用于序列化标注的对数线性模型]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>日积月累</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab的文件操作]]></title>
    <url>%2Fmatlab%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[2018-5-9 1. fopen、fprintf与fscanf的用法 FID = fopen(file_name, mode) 参数：file_name：输入文件的名字，以字符串的形式读入mode：读入文件的模式，如下表所示 mode 功能 r 只读 w 覆盖式写入文件，如果文件不存在就创建该文件 a 添加式写入，不清除原文件，直接在该文件后面续写 r+ 打开已经存在的文件来进行读写 w+ 重新刷新读入与写入 a+ 对文件进行添加式读写操作， 如果文件不存在就创建该文件 在写入文件时，如果该文件不存在则会创建该文件，文件打开的默认存储格式是二进制的，如果以文本方式打开，则在mode中加入t，例如’rt’或’wt’ 返回值：FID=n，如果n是正整数，则表示读入文件成功且n表示文件代号，如果FID=-1则读入文件失败，FID类似于python中的文件对象，在文件关闭前FID都是有效的。 示例：12fid = fopen('test.txt','w+') % 打开一个文件，返回的fid为一个正整数，假设为fid=7fclose(fid) % 关闭文件号为fid=7的文件 fopen()函数仅打开了一个文件并返回其文件代号，但无法直接读取文件的内容，所以需要使用fscanf()函数来将文件代号对应文件中的内容读入到字符串变量中，类似于python文件中的readline()函数 [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE, SIZE) 参数：FID：为fopen()函数返回的文件代号TEMPLAGE：输入数据的格式，如下表所示 SIZE：该参数是针对读取文件内容篇幅的，将文本当做矩阵，SIZE表示返回VAL矩阵的行列值,从原文件读入数据是按照行进行，但是在返回VAL时会将数据按列优先来排列，直到满足SIZE，然后忽略其余数据，SIZE除了取[m,n]类型外，也可以直接取数，取的数决定了VAL的数据的量，如果为inf则直接读取文件的所以内容 表-1 格式描述符 TEMPLATE类型 功能 %d 整数 %e 实数，科学计数法形式 %f 实数，小数形式 %g 会输出整数或实数，由数本身决定，但末尾的0会省去 %s 输出字符串格式 %c 输出字符格式 返回值：VAL：返回的文件内容，可以是字符串也可以是数字COUNT：返回的字符串或数字的个数ERRMSG：当读取文件失败时才会输出stream not open for reading，读入文件正确时该项为空 示例： test.txt文件中内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 12345678910111213141516 fid = fopen('test.txt'); [f1, c1, e1] = fscanf(fid, '%d', [2,3]); % 输出如下% f1 =% 1 3 5% 2 4 6% c1 = 6% e1 = fseek(fid, 0,-1); % 将文件位置指针指向文件头 % 输出ans = 0[f1, c1, e1] = fscanf(fid, '%d', [3,3]); % 输出如下% f1 =% 1 4 7% 2 5 8% 3 6 9% c1 = 6% e1 = 读取文件时类型混合无法直接读取，文件如下：1 hello2 world3 happy只能分别使用fscanf(fid, &#39;%d&#39;, 1)与fscanf(fid, &#39;%s&#39;, 1)按数据类型逐个读入数据(这里使用octave实验)。 这里需要注意，每次使用fscanf()函数读取文件后，文件的指针会移动到当前读取的位置，例如在test.txt示例中，文件指针当前指向数据7，所以必须将文件指针回到文件的开头才能再次使用该文件，这里使用fseek()函数来修改文件的指针 status = fseek(fid, offset, origin) 参数：fid：文件代号或文件句柄offset：&gt;0 向文件末尾移动； =0 保持位置不变； &lt;0 向文件开头移动origin：文件位置指针移动的参考位置， ‘bof’ 或 -1表示文件的开头； ‘cof’或0表示文件的当前位置； ‘eof’或1表示文件的末尾返回值：status=0表示改变指针位置成功，否则返回-1 count = fprintf (fid, template, variable) 参数：fid：文件代号或文件句柄，当该项为空时，直接输出到屏幕中template：输出文件的格式，与输入的格式描述相同，见上表-1variable：要输出的变量返回值：count：按文件描述符格式划分的数据个数]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>fopen</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统安装及软件配置]]></title>
    <url>%2Flinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[2017-11-29 1.安装ubunut系统时一直卡在图标的位置无法进入安装界面将系统bios里security boot设置为disable，重启后再重新进入安装状态； 如果仍然无法进入安装状态：在选择安装和试用的界面，将光标移动到ubunt上，按 ‘e’，系统进入一个设置界面，在quiet splash后面加 nomodeset(别忘了空格)，然后按F10后系统以不设置显示模式的状态可以进入安装界面，但此时分辨率较低，尤其在选择分区后无法直接点击“安装”按钮，而且无法点击菜单栏拖动，此时使用alt + 鼠标左键可以拖动窗口，然后按步骤安装系统即可。 2.电脑安装ubuntu16.04后重启一直黑屏无法进入系统 可能和电脑的intel核显卡和nvidia集成显卡的驱动有关，此时再以上面的nomodeset模式进入系统，使用指令sudo apt-get install nvidia-current，然后重启可以成功进入系统。 如果没有进入系统又卡在黑屏界面，则使用另一种方法： 1使用nomodeset模式进入系统，先安装Intel的核心显卡驱动，去官网下载update-tool工具，这是我下载的版本intel-graphics-update-tool_2.0.2_amd64.deb，然后安装即可。 sudo dpkg -i intel-graphics-update-tool_2.0.2_amd64.deb sudo apt-get -f install sudo apt-get update安装完成后使用glxinfo | grep rendering可以查看安装的结果，显示yes表示安装成功 2安装nvidia的显卡驱动 lspci | grep -i nvidia查看电脑是否支持英伟达显卡，安装官网安装驱动 a关闭图像界面和禁用nouveau 进入字符界面ctrl + alt + f1后登录，sudo serivce lightdm stop关闭图像界面服务，禁用nouveau第三方驱动(步骤略)，lsmod | nouveau无输出则禁用成功 b 安装nvidia的deb文件即可 安装完成后使用cat /proc/driver/nvidia/version查看驱动版本，使用nvidia-smi也可以查看驱动及显卡的硬件信息 所有的驱动安装完成后，重启进入系统，如果还没有进入系统，则按上述的办法重安nvidia驱动，使用sudo apt-get remove nvidia和sudo /usr/bin/nvidia-uninstall将驱动卸载干净再重新安装。 3.配置sublime + python3的运行环境3.1 首先在ubuntu16.04下安装sublime text3 sudo add-apt-repository ppa:webupd8team/sublime-text-3 添加apt的安装包来源sudo apt-get update 更新软件源sudo apt-get install sublime-text-installer 安装sublime text 安装完成后输入subl 文件名，如果该⽂件存在就会以sublime text打开， 否则就创建该⽂件， 默认的有代码提⽰和⾼亮功能， 选择运⾏的环境后， Ctrl + B 可以编译运⾏编写的代码 PPA 全称为 Personal Package Archives（个⼈软件包档案） ,通常 PPA 源⾥的软件是官⽅源⾥没有的， 或者是最新版本的软件。 相对于通过 Deb 包安装来说， 使⽤ PPA 的好处是， ⼀旦软件有更新， 通过sudo apt-get upgrade 这样命令就可以直接升级到新版本。在 Ubuntu Karmic (9.10) 我们可以使⽤ add-apt-repository 脚本添加 ppa 到当前的库中并且⾃动导⼊公钥。 在终端下使⽤语法： add-apt-repository ppa:&lt;ppa_name&gt; 3.2 配置python3环境 A 新建运行环境使用Tools==&gt;Build System==&gt;New Build Systems生成一个配置文件，我们可以改 名字为python3.sublime-build，python3就成为了build system中的一个选项了，在该文件中写入： 1234567&#123;"shell_cmd": "python3 -u \"$file\"","file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)","selector": "source.python",&#125; 保存后在build system中选择python3，使用ctrl + B就可以运行代码了123import sysprint(sys.version)print(sys.version_info) 上面的代码可以输出使用的python版本，python2版本可以直接选择Tools==&gt;build system中的python就行，应为在系统中默认的是python2，所以这里要构建python3的运行环境。B 在sublime中加入anaconda的插件，特别好使先安装package control，然后安装anaconda的插件，点击Preferences==&gt;Package Settings==&gt;Anaconda==&gt;Settings User生成文件Anaconda.sublime-settings，里面写入下面代码：1234567891011121314&#123;&quot;anaconda_linting&quot;: false,//保存文件后自动pep8格式化&quot;auto_formatting&quot;: true,&quot;enable_signatures_tooltip&quot;: false,// close the document in the function or packages&quot;python_interpreter&quot;: &quot;/usr/bin/python3&quot;&#125; 配置后，函数可以补全，可以查看定义等 3.3 解决sublime无法输入中文问题sudo apt-get update &amp;&amp; sudo apt-get upgrade 克隆项目到本地 git clone https://github.com/lyfeyaj/sublime-text-imfix.git 运行脚本cd sublime-text-imfix &amp;&amp; ./sublime-imfix 最后重启即可如果上述方法不可行，则： 1将sublime-test-imfix/lib路径下的libsublime-imfix.so拷贝到sublime的文件夹下 2 将sublime-test-imfix/src路径下的subl文件拷贝到/usr/bin/路径下并作修改如下： 123#!/bin/shexport LD_PRELOAD=/you_install_path/sublime_text/libsublime-imfix.soexec /you_install_path/sublime_text/sublime_text &quot;$@&quot; 使用subl就可以打开sublime并输入中文了 4.ubuntu安装vnc服务器 sudo apt-get install tightvncserver 安装VNC服务器tightvncserver 启动vnc服务器， 之后会要求输⼊密码， 任意输⼊密码（⼤于6个数） 打开vnc viewer软件， 输⼊IP:n ,IP为vnc服务器的ip地址， n代表打开的窗⼝个数， 连接vnc服务器， 输⼊刚才在服务器上的密码进⼊系统 5.ubuntu安装ftp服务器 ⾸先服务器要安装ftp软件,查看是否已经安装ftp软件下：sudo apt-get install vsftpd 安装ftp软件which vsftpd 查看软件是否安装成功如果看到有vsftpd的⽬录说明服务器已经安装了f tp软件 查看ftp 服务器状态service vsftpd status ,输出ftp服务器的状态 启动ftp服务器service vsftpd start 启动ftp服务器 重启ftp服务器service vsftpd restart 重启f tp服务器 参考:http://blog.csdn.net/f t1512975/article/details/6620227 6.ubuntu使用screen在ssh下查看历史历史窗口sudo apt-get install screen 安装该软件screen 开启一个新窗口，该窗口和普通的窗口功能一样当我们在该窗⼝执⾏程序时， 当前screen窗⼝中键⼊C-a d，即Ctrl键+a键， 之后再按下d键,会退回到screen前的窗⼝， 该命令的好处是虽然我们退出了ssh连接， 但是我们的程序任然在执⾏中， 我们可以⽤ssh再次连接后， 使⽤ top 指令可以查看程序的运⾏状态， 但⽆法恢复之前的运⾏界⾯， ⽽screen可以做到，监控窗口已关闭但依然在运行的程序，并调出该窗口。 使⽤ screen -ls 列出screen窗⼝运⾏的数量， 每个窗⼝都有⾃⼰的编号，使⽤ screen -r 窗⼝的编号 连接之前退出的screen窗⼝(该窗⼝的退出⽅式必须是 C-a d )exit 可以退出当前的窗⼝， 并返回之前的窗⼝C-a ? 显⽰所有键绑定信息C-a w 显⽰所有窗⼝列表C-a C-a 切换到之前显⽰的窗⼝C-a c 创建⼀个新的运⾏shell的窗⼝并切换到该窗⼝C-a n 切换到下⼀个窗⼝ C-a p 切换到前⼀个窗⼝(与C-a n相对) C-a 0..9 切换到窗⼝0..9 C-a a 发送C-a到当前窗⼝ C-a d 暂时断开screen会话 C-a k 杀掉当前窗⼝ C-a进⼊拷贝/回滚模式 参考：在ssh、telnet断开之后继续执行程序 7.ubuntu以root身份打开文件管理器(GNOME) sudo nautilus 以root用户打开文件管理器，可以在根目录的文件夹下进行操作]]></content>
      <categories>
        <category>ubuntu系统</category>
      </categories>
      <tags>
        <tag>ubuntu系统</tag>
        <tag>sublime配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker在ubuntu上的安装及使用]]></title>
    <url>%2Fdocker%E5%9C%A8ubuntu%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[2018-3-30 1.安装前的准备工作 确保是64位的操作系统 卸载旧版本的dockersudo apt-get remove docker docker-engine docker.iodockerde相关文件都在/var/lib/docker/路径下 2.使用docker仓库安装 首次安装docker时需要添加docker的仓库 更新软件源的仓库信息sudo apt-get update 安装包来使apt通过HTTPS来使用docker仓库sudo apt-get install apt-transport-https ca-certificates \curl software-properties-common 添加docker的官方GPG证书curl -fsSL https://download.docker.com/linux/ubuntu/gpg \| sudo apt-key add - 验证是否添加成功带有fingerprint的keysudo apt-key fingerprint 0EBFCD88 添加稳定的docker仓库sudo add-apt-repository \&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable&quot; 安装docker-ce 再次更新仓库信息sudo apt-get update 指令安装docker注意:sudo apt-get install docker-ce只能安装目前最高的版本,但通常使用下面方法来选择要安装的版本apt-cache madison docker-ce查看目前的多个版本,结果如下: 使用sudo apt-get install docker-ce=&lt;VERSION&gt;安装特定的版本,这里使用17.12.0版本,指令为:sudo apt-get install docker-ce=17.12.0~ce-0~ubuntu 验证安装的结果如果安装docker安装正确,则运行sudo docker run hello-world后输出下面结果: 其他详细的安装详情见官网 https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce-1 4.创建docker组 该操作的作用:不用每次使用docker指令时都输入sudo 创建docker组sudo groupadd docker创建docker组cat /etc/group | grep -i docker查看docker组的基本情况如下,目前该组中还没有添加用户: 2.为docker组添加用户sudo usermod -aG docker $USER,其中$USER表示当前的用户,再次查看docker用户组的信息如下,该组中多了个david用户(当前登录的用户): 注销登录后,用户组生效,就可以直接使用不带sudo的docker指令 5.安装nvidia-docker来支持GPU 卸载旧版本的nvidia-docker及GPU容器docker volume ls -q -f driver=nvidia-docker | \xargs -r -I{} -n1 docker ps -q -a -f volume={} | \xargs -r docker rm -fsudo apt-get purge -y nvidia-docker 添加仓库 添加key:curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \ sudo apt-key add - 获取系统版本号:distribution=$(. /etc/os-release;echo $ID$VERSION_ID) 添加仓库:curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \sudo tee /etc/apt/sources.list.d/nvidia-docker.list 更新仓库信息sudo apt-get update 安装nvidia-docker2并配置docker dameon加速镜像下载 安装nvidia的gpu支持:sudo apt-get install -y nvidia-docker2 修改/etc/docker/daemon.json文件内容如下:123456789 &#123; "registry-mirrors": ["http://58167a06.m.daocloud.io"], "runtimes": &#123; "nvidia": &#123; "path": "/usr/bin/nvidia-container-runtime", "runtimeArgs": [] &#125; &#125;&#125; 其中链接部分是使用国内的加速镜像,这里使用dalcloud的加速镜像,如果使用阿里云的加速镜像,将链接替换为https://8vntriz8.mirror.aliyuncs.com即可,该链接是在注册阿里开发者平台时生成的,具体的细节见https://www.cnblogs.com/atuotuo/p/6264800.html. 重载daemon使配置生效,并重启docker:sudo pkill -SIGHUP dockerdsudo systemctl daemon-reloadsudo systemctl restart docker 测试安装情况docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi会下载cuda镜像来测试 5.使用docker安装tensorflow 打开tensorflow的docker镜像仓库如下: 使用指令nvidia-docker run -it -p 8888:8888 tensorflow/tensorflow:&lt;mirror tag&gt;下载并运行tag对应的镜像,这里使用tag为1.7.0-gpu-py3的镜像输出结果如下. 将最下面的链接复制到浏览器就可以打开ipython notebook并使用对应的镜像环境了. 注意:首次运行上面的指令会下载对应tag的镜像,之后运行可以直接从本地读取该镜像. 使用docker images查看已下载镜像信息,结果如下: 使用docker rmi -f &lt;IMAGE ID&gt; 删除对应ID号的镜像. 6.将主机的目录挂载到容器中 首先使用docker ps查看目前运行的容器，结果如下，使用docker kill &lt;container ID&gt;关闭ID号对应的容器: 使用docker exec -it 2783ad1bf2dc /bin/bash登录该容器,其中2783ad1bf2dc为第一步的结果中看到的容器ID号,登录的结果如下: 登录成功后,终端的用户和工作组组也随着改变,该容器的目录结构与一般的Linux相同,输入exit或使用按键ctrl + d退出登录状态. OPTIONS说明： -d :分离模式: 在后台运行 -i :标准输入,即使没有附加也保持STDIN 打开 -t :分配一个伪终端,后面必须加/bin/bash 这里将/home/david/docker/tensorflow目录挂载到1.7.0-gpu-py3容器的/notebooks/tensorflow目录下,将主机的目录挂载到容器后,修改主机的文件,容器中的文件也会同步更新,这样比较方便,操作如下:docker run -it -v &lt;主机目录&gt;:&lt;容器挂载目录&gt; &lt;容器镜像&gt; /bin/bash, -v表示挂载目录的选项;冒号前面是主机目录,后面是容器目录;最后面接容器镜像 这里的挂载目录操作:docker run -it -v /home/david/docker/tensorflow:/notebooks/tensorflow tensorflow/tensorflow:1.7.0-gpu-py3 /bin/bash 查看挂载结果如下: 可以看出,在容器的/notebooks目录下已经出现了tensorflow目录,并且该文件夹下已经出现了在主机目录/home/david/docker/tensorflow里的test.py文件,即目录挂载成功. 注意:使用下面指令可以一步到位!打开ipython notebook并挂载主机目录到容器.docker run -it -v /home/david/docker/tensorflow:/notebooks/tensorflow -p 8888:8888 tensorflow/tensorflow:1.7.0-gpu-py3 运行结果:]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dlib安装总结]]></title>
    <url>%2Fdlib%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2017-8-10 1.dlib安装步骤ubuntu下最好别用anaconda，会出现很多问题，宁可自己安装各种包！ sudo apt-get install build-essential cmakesudo apt-get install libgtk-3-devsudo apt-get install libboost-all-devsudo apt-get install libopenblas-dev liblapack-dev # 提高cpu处理速度 pip install scikit-imagesudo apt-get install python-skimagepip install dlib 如果pip安装失败，可以直接从pypi上下载安装包，离线安装！如果dlib指令安装失败还可以编译源码，源码里使用sudo python setup.py install，就可以安装了，仅python的API，前提是setuptools已经安装完成。 2.ubuntu16.06安装opencv3.31.安装各种依赖库 [compiler] sudo apt-get install build-essential[required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev[optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 2.下载源码后生成编译文件2.1创建一个文件夹用来放cmake后的编译文件 cd ~/opencvmkdir buildcd build 2.2cmake后创建make所需的文件 cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. build文件夹下会产生makefile文件用于编译，cmake的编译选项还有其他的，但目前用上面的就够了，python的接口也包含进去了 3.编译源码产生对象文件(.o文件) make -j4 # j4表示开启4个线程sudo make install # 安装opencv库到系统中 配置opencv.conf file ，加入环境变量 sudo gedit /etc/ld.so.conf.d/opencv.conf 如果没有该文件，则上述的命令会创建该文件，在opencv.conf里面加入 /usr/local/lib sudo ldconfig #更新库目录Ubuntu 安装OpenCV3.0.0 blog里还有下述步骤：打开文件bash.bashrcsudo gedit /etc/bash.bashrc 加入下面两行PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfigexport PKG_CONFIG_PATH 我这里进行测试，没有该步骤也行！ 5.测试opencv5.1 C++版本 1234567#include "opencv2/opencv.hpp"using namespace cv; int main() &#123; Mat src = imread("test3.jpg",1); imshow("src",src); waitKey(0); return 0; &#125; 编译方式：1 命令行1g++ opencvtest.cpp -o opencvtest `pkg-config --cflags --libs opencv` cflags前面是两个横线 2 借助cmake，写CMakeLists.txt 12345cmake_minimum_required(VERSION 2.8)project(opencvtest)find_package( OpenCV REQUIRED )add_executable( opencvtest opencvtest.cpp )target_link_libraries( opencvtest $&#123;OpenCV_LIBS&#125; ) 之后 执行 cmake .Make # 生成可执行文件./ test # 运行程序进行测试 5.2python版本1234import cv2img = cv2.imread('test3.jpg',1)cv2.imshow('img',img)cv2.waitKey(0) python test.py #运行该出现，会显示一张图片 至此opencv的配置完成！ 3.virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头 cheese #在ubuntu里可以打开摄像头 如果打不开，则需要设置virtualbox。 1.首先去官网下载virtualbox的扩展包进行安装，如下图： 然后设置虚拟机的usb选项，并勾选设备选项里的摄像头选项 设置好后再使用cheese指令打开摄像头，或运行与摄像头相关的程序，由于是虚拟机的原因摄像头比较卡。 4.whl文件安装中的问题处理 原文件： opencv_python-3.1.0-cp34-cp34m-win_amd64.whl，改后的文件：opencv_python-3.1.0-cp34-none-win_amd64.whl 把原来文件名中间的cp34m变为none(其实不改也能安装成功)，并且cp34要和python的版本对应，如cp36表示python版本3.6，如果不改的话不然会出现下面的问题：(但只是更改版本号可能会带来兼容性问题) opencv_python-3.1.0-cp34-cp34m-win_amd64.whl is not a supported wheel on this platform. pip3 install 路径名\opencv_python-3.1.0-cp34-none-win_amd64.whl安装该模块 5. pip换源提升安装库的速度和稳定性网上有很多可用的源，豆瓣：http://pypi.douban.com/simple/ 清华：https://pypi.tuna.tsinghua.edu.cn/simple pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名 这样就会从清华这边的镜像去安装库。 更改配置文件：1.Linux系统修改~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 2.windows直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 进过不断的试错，总结如下： 1.首先为pip换源，这样大部分的库可以直接指令安装 2.换源后安装失败的，可以在[source1][7]和[source2][8]下载whl文件离线安装 3.大部分依赖库安装失败都是下载失败导致，所以上述两种方法可以解决大部分问题 更改pip源至国内镜像，显著提升下载速度]]></content>
      <categories>
        <category>Python</category>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>dlib</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记]]></title>
    <url>%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[2018-2-3 1. C++的头文件和源文件.h头文件只需预处理，.cpp才需要编译，一般在头文件里声明一个类及类的的方法，在源文件里实现函数的定义与实现，这样可以将声明和定义分开，利于构建大规模的程序。hello.h文件如下：12345678910111213141516#pragma once //预编译一次，防止出现重复包含头文件的情况#include "iostream"#include "string"using namespace std;class Hello&#123;public: //共有函数及成员定义的关键词 Hello(); //声明构造函数，构造函数最好不要有默认参数 ~Hello(); //声明析构函数 void talk(int number=0); //声明共有成员函数,参数给出默认值 private: //私有函数及成员定义的关键词 string content; //声明一个字符串变量 int num;&#125;; hello.cpp文件如下：12345678910111213141516171819#include "hello.h"//类的定义与实现Hello::Hello() //构造函数定义&#123; content = "这是私有成员变量"; //在构造函数中为成员变量赋值 cout &lt;&lt; "这是构造函数" &lt;&lt; endl;&#125;Hello::~Hello() //析构函数定义&#123; cout &lt;&lt; "这是析构函数" &lt;&lt; endl;&#125;void Hello::talk(int number) //成员函数定义&#123; num = number; cout &lt;&lt;"content:"&lt;&lt; content &lt;&lt; endl; //头文件中包含了string才能使用该句 cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;&#125; 主函数main.cpp如下：12345678910#include "iostream"#include "hello.h"using namespace std;int main()&#123; Hello robot; //实例化一个对象 robot.talk(233); //调用成员函数，默认参数为0 return 0;&#125; 运行结果如下： 2. C++中的L和_T的作用在一个字符串前加 L表示将ANSI字符串转换为unicode的字符串，每个字符占两个字节12strlen("abc") = 3;strlen(L"asd") = 6; _T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式，如果你定义了UNICODE，那么_T宏会把字符串前面加一个L。这时 _T(“ABCD”) 相当于 L”ABCD” ，这是宽字符串。如果没有定义，那么_T宏不会在字符串前面加那个L，_T(“ABCD”) 就等价于 “ABCD” 3. C++调用Python函数的方法 这里使用vs2015编译程序，首先要设置项目的属性，把python的include目录和libs目录包含到项目中，设置如下： python程序如下： 1234 # pythondef convertStrToNum(string): result = eval(string) return result 这里的python程序当做模块来对待，文件夹名称为strToNum，文件名strToNum.py，在同一个文件夹下有init.py文件(内容可为空)来表示模块。 在C++程序中调用python函数时注意：python语句写成模块的形式；将python模块的路径添加到系统中，否则c++程序无法找到python模块，最好使用相对路径； 步骤： 1.Py_Initialize()初始化python; 2.定义PyObject相关指针， 载入python模块 加载模块函数 添加参数列表 调用python函数 定义C++数据变量，转换python返回的参数为C++的数据类型，并用该变量接收 3.Py_Finalize()释放资源 c++程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 #include "iostream"#include "Python.h"#include "string"#include "cstring"using namespace std;int main()&#123; Py_Initialize(); //PyRun_SimpleString("x=eval('2 + 3*2')"); //运行单个python语句 //PyRun_SimpleString("print(x)"); //PyArg_Parse(x, "i"); // 将Python工作路径切换到待调用模块所在目录，一定要保证路径名的正确性 string path = ".\\strToNum"; //相对路径，windows下 string chdir_cmd = string("sys.path.append(\"") + path + "\")"; const char* cstr_cmd = chdir_cmd.c_str(); PyRun_SimpleString("import sys"); PyRun_SimpleString(cstr_cmd); PyRun_SimpleString("import os"); PyRun_SimpleString("print(os.getcwd())"); //获取当前路径 PyRun_SimpleString("print(sys.path)"); PyObject *pModule = NULL; //接收python模块 PyObject *pFunc = NULL; //接收pyhton函数 PyObject *pResult = NULL; //接收python函数的返回结果 double result = 0; //C++中接收最终计算结果的变量 pModule = PyImport_ImportModule("strToNum"); if (!pModule) // 加载模块失败 &#123; cout &lt;&lt; "[ERROR] Python get module failed." &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Python get module succeed." &lt;&lt; endl; pFunc = PyObject_GetAttrString(pModule, "convertStrToNum"); if (!pFunc || !PyCallable_Check(pFunc)) // 验证是否加载成功 &#123; cout &lt;&lt; "[ERROR] Can't find funftion (convertStrToNum)" &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Get function (convertStrToNum) succeed." &lt;&lt; endl; PyObject *pArgs = PyTuple_New(1); //新建数组保存传入python函数的参数 PyTuple_SetItem(pArgs, 0, Py_BuildValue("s", "1 + 2*4.3 -1")); //PyObject *pArgs = Py_BuildValue("23"); pResult = PyEval_CallObject(pFunc, pArgs); //调用python函数 PyArg_Parse(pResult, "d", &amp;result); //python函数的返回结果转换为double cout &lt;&lt; "result:" &lt;&lt; result &lt;&lt; endl; Py_Finalize(); //释放资源 return 0;&#125; 参考的文章： C++调用python返回值 调用python的类函数 使用与pyhton的C++扩展]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++调用Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[1. python里args和*kwargs的用法引入参数*args和**kwargs，两个都是python中的可变参数。*args表示任何多个无名参数，它是一个tuple**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前12345678910def foo(*args, **kwargs): print 'args = ', args print 'kwargs = ', kwargs print '---------------------------------------'if __name__ == '__main__': foo(1,2,3,4) #参数只传到*args中 foo(a=1,b=2,c=3) #参数只传到**kwargs中 foo(1,2,3,4, a=1,b=2,c=3) #参数可以传到*args和**kwargs中 foo('a', 1, None, a=1, b='2', c=3) 运行结果：123456789101112args = (1, 2, 3, 4)kwargs = &#123;&#125;---------------------------------------args = ()kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = (1, 2, 3, 4)kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = ('a', 1, None)kwargs = &#123;'a': 1, 'c': 3, 'b': '2'&#125;--------------------------------------- 2.python对txt文件的操作2.1 使用open() 函数读取文本内容，本函数是打开一个文件并返回文件对象。如果文件不能打开，抛出异常OSErroropen(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=T)参数mode是指明打开文件的模式。默认值是’r’，表示使用文本的方式打开文件来读取。 ‘r’表示打开文件只读，不能写。 ‘w’表示打开文件只写，并且清空文件。 ‘x’表示独占打开文件，如果文件已经存打开就会失败。 ‘a’表示打开文件写，不清空文件，在文件后尾追加的方式写入。 ‘b’表示二进制的模式打开文件。 ‘t’表示文本模式，默认情况下就是这种模式。 ‘+’打开文件更新（读取或写入）。 缺省时的模式就相当于’rt’。比如’w+b’就是打开文件进入读写，把文件清空；’r+b’打开文件，但不把文件清空打开文件的操作常使用异常捕捉来 str.strip(rm)方法,去除字符串开头和结尾的rm字符，readline()获取的是一行文本的字符串形式1234567891011121314151617def open_file(filename): """打开一个文件，存储到列表中，并返回该列表""" try: with open(filename) as file_open: #打开文件，因为只有一行，所以不用使用循环 data = file_open.readline() # [james,james2,james3] = data.strip().split(',', 2) #方法串链，从左向右作用 file_data = data.strip().split(',') """split方法返回字符串列表，如果只是一个标识符接受，则不会报错 如果是[list1,list2,...]的形式则有可能因为接受数据的列表元素个数，与返回的 字符串列表的个数不一致而导致ValueError""" return file_data except IOError as ioerr: print 'IOError:' + str(ioerr) return None except ValueError as valerr: print 'ValueError:' + str(valerr) return None (role, line_spoken) = each_line.split(&#39; ,&#39;)，多重赋值(),[]均可以接受数据-字符串列表，each_line本身不会被分割，保持不变[role, line_spoken] = each_line.split(&#39;, &#39;,1)[string1, string2, string3] = each_line.split(&#39;, &#39;, 2)如果分割后的字符首位有“空格”，也会把其当成字符串第二个参数表示使用的分割符的个数，使用1则分为两个部分，如果不加则表示只要存在分隔符就会分解,n个分隔符分为n+1个部分，空字符也算入被分割的部分 2.2 使用open() 函数和file_object.write() 方法写入文本方法一、增加额外的逻辑来处理异常,使用finally来关闭文件对象1234567891011121314try: #文件写入过程 man_file = open('man_data.txt', 'w') #新建文件 other_file = open('other_data.txt', 'w') """ write()与print都可以写入数据，当print可以由字符串或列表写入， write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # print &gt;&gt; man_file, man #文件对象里传入数据 # print &gt;&gt; other_file, other man_file.write(str(man)) other_file.write(str(other))except IOError: print 'File error.'finally: #无论有无异常，此句都会执行， man_file.close() other_file.close() 方法二、with处理文件异常,不用考虑关闭文件对象123456789101112131415try: #文件写入过程 # with open('man_data.txt', 'w') as man_file: #新建文件 # # print &gt;&gt; man_file, man #文件对象里传入数据 # man_file.write(str(man)) # with open('other_data.txt', 'w') as other_file: # """ write()与print都可以写入数据，当print可以由字符串或列表写入， # write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # # print &gt;&gt; other_file, other # other_file.write(str(other)) with open('man_data.txt', 'w') as man_file, open('other_data.txt', 'w') as other_file: #两个语句合并为一个with语句 man_file.write(str(man)) other_file.write(str(other))except IOError as err: print 'File error:' + str(err) 2.3实例打开train_data.txt，读取其中的前四行，然后存储到train_data2.txt文件里 1234567891011121314151617181920212223# encoding:utf-8# file.readlines()读取数据的行数，'行数据\n' 是该方法输出列表的每行数据的元素attribute_data = []try: with open('./train_data.txt') as file, open('./train_data2.txt','w') as file2: raw_number = len(file.readlines()) # 计算文件的总行数 file.seek(0) # 回到第一行，因为每次使用readline，文本都会后退一行 for i in range(raw_number): # 计算文件的总行数，设计循环逐行读入数据 text_line = file.readline() # 每次调用该函数使文件下移一行 # temp_file = text_line.strip().split(' ', 32) # temp_file存储分割后的数据列表 # attribute_data = temp_file[0:2] + temp_file[12:32] # 存储要使用的数据列 temp_file = text_line.strip().split(' ', 4) # temp_file存储分割后的数据列表 attribute_data = temp_file[0:4] # 存储要使用的数据列 for data in attribute_data: # 逐行写入数据,只能每个字符分别读入，才可以在数据中间插入空格 file2.writelines(data) file2.writelines(' ') # 数据间加入空格 file2.writelines('\n') # 数据换行except IOError as err: print 'File error:' + str(err)print attribute_data ` 3.python函数shutil，实现文件的复制使用shutil.copy(str_file1,str_file2)将文件str_file1，复制到文件str_file2的位置 4.python实现读取文件夹里文件名功能123import os path = 'the path of the directory' # 读取文件路径list_name = os.listdir(path) # 读取路径下文件和文件夹的名 则list_name就是文件夹里所以子文件夹和文件的列表，可以通过os.path.isfile和os.path.isdir来对列表里的项进行判断看是文件还是文件夹。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
