<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dlib安装总结]]></title>
    <url>%2Fdlib%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2017-8-10 1.dlib安装步骤ubuntu下最好别用anaconda，会出现很多问题，宁可自己安装各种包！ sudo apt-get install build-essential cmakesudo apt-get install libgtk-3-devsudo apt-get install libboost-all-devsudo apt-get install libopenblas-dev liblapack-dev # 提高cpu处理速度 #pip install scikit-imagesudo apt-get install python-skimagepip install dlib 如果pip安装失败，可以直接从pypi上下载安装包，离线安装！如果dlib指令安装失败还可以编译源码，源码里使用sudo python setup.py install，就可以安装了，仅python的API，前提是setuptools已经安装完成。 2.ubuntu16.06安装opencv3.31.安装各种依赖库 [compiler] sudo apt-get install build-essential[required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev[optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 2.下载源码后生成编译文件2.1创建一个文件夹用来放cmake后的编译文件 cd ~/opencvmkdir buildcd build 2.2cmake后创建make所需的文件 cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. build文件夹下会产生makefile文件用于编译，cmake的编译选项还有其他的，但目前用上面的就够了，python的接口也包含进去了 3.编译源码产生对象文件(.o文件) make -j4 # j4表示开启4个线程sudo make install # 安装opencv库到系统中 配置opencv.conf file ，加入环境变量 sudo gedit /etc/ld.so.conf.d/opencv.conf 如果没有该文件，则上述的命令会创建该文件，在opencv.conf里面加入 /usr/local/lib sudo ldconfig #更新库目录 Ubuntu 安装OpenCV3.0.0 blog里还有下述步骤：打开文件bash.bashrc sudo gedit /etc/bash.bashrc 加入下面两行 PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfigexport PKG_CONFIG_PATH 我这里进行测试，没有该步骤也行！ 5.测试opencv5.1 C++版本 1234567#include "opencv2/opencv.hpp"using namespace cv; int main() &#123; Mat src = imread("test3.jpg",1); imshow("src",src); waitKey(0); return 0; &#125; 编译方式：1 命令行1g++ opencvtest.cpp -o opencvtest `pkg-config --cflags --libs opencv` cflags前面是两个横线 2 借助cmake，写CMakeLists.txt 12345cmake_minimum_required(VERSION 2.8)project(opencvtest)find_package( OpenCV REQUIRED )add_executable( opencvtest opencvtest.cpp )target_link_libraries( opencvtest $&#123;OpenCV_LIBS&#125; ) 之后 执行 cmake .Make # 生成可执行文件./ test # 运行程序进行测试 5.2python版本1234import cv2img = cv2.imread('test3.jpg',1)cv2.imshow('img',img)cv2.waitKey(0) python test.py #运行该出现，会显示一张图片 至此opencv的配置完成！ 3.virtualbox虚拟机的ubuntu系统下打开笔记本自带的摄像头 cheese #在ubuntu里可以打开摄像头 如果打不开，则需要设置virtualbox。 1.首先去官网下载virtualbox的扩展包进行安装，如下图： 然后设置虚拟机的usb选项，并勾选设备选项里的摄像头选项 设置好后再使用cheese指令打开摄像头，或运行与摄像头相关的程序，由于是虚拟机的原因摄像头比较卡。 4.whl文件安装中的问题处理 原文件： opencv_python-3.1.0-cp34-cp34m-win_amd64.whl，改后的文件：opencv_python-3.1.0-cp34-none-win_amd64.whl 把原来文件名中间的cp34m变为none(其实不改也能安装成功)，并且cp34要和python的版本对应，如cp36表示python版本3.6，如果不改的话不然会出现下面的问题：(但只是更改版本号可能会带来兼容性问题) opencv_python-3.1.0-cp34-cp34m-win_amd64.whl is not a supported wheel on this platform. pip3 install 路径名\opencv_python-3.1.0-cp34-none-win_amd64.whl安装该模块 5. pip换源提升安装库的速度和稳定性网上有很多可用的源，豆瓣：http://pypi.douban.com/simple/ 清华：https://pypi.tuna.tsinghua.edu.cn/simple pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名 这样就会从清华这边的镜像去安装库。 更改配置文件：1.Linux系统修改~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 2.windows直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 进过不断的试错，总结如下： 1.首先为pip换源，这样大部分的库可以直接指令安装 2.换源后安装失败的，可以在source1和source2下载whl文件离线安装 3.大部分依赖库安装失败都是下载失败导致，所以上述两种方法可以解决大部分问题 更改pip源至国内镜像，显著提升下载速度]]></content>
      <categories>
        <category>Python</category>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>dlib</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习笔记]]></title>
    <url>%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[2018-2-3 1. C++的头文件和源文件.h头文件只需预处理，.cpp才需要编译，一般在头文件里声明一个类及类的的方法，在源文件里实现函数的定义与实现，这样可以将声明和定义分开，利于构建大规模的程序。hello.h文件如下：12345678910111213141516#pragma once //预编译一次，防止出现重复包含头文件的情况#include "iostream"#include "string"using namespace std;class Hello&#123;public: //共有函数及成员定义的关键词 Hello(); //声明构造函数，构造函数最好不要有默认参数 ~Hello(); //声明析构函数 void talk(int number=0); //声明共有成员函数,参数给出默认值 private: //私有函数及成员定义的关键词 string content; //声明一个字符串变量 int num;&#125;; hello.cpp文件如下：12345678910111213141516171819#include "hello.h"//类的定义与实现Hello::Hello() //构造函数定义&#123; content = "这是私有成员变量"; //在构造函数中为成员变量赋值 cout &lt;&lt; "这是构造函数" &lt;&lt; endl;&#125;Hello::~Hello() //析构函数定义&#123; cout &lt;&lt; "这是析构函数" &lt;&lt; endl;&#125;void Hello::talk(int number) //成员函数定义&#123; num = number; cout &lt;&lt;"content:"&lt;&lt; content &lt;&lt; endl; //头文件中包含了string才能使用该句 cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;&#125; 主函数main.cpp如下：12345678910#include "iostream"#include "hello.h"using namespace std;int main()&#123; Hello robot; //实例化一个对象 robot.talk(233); //调用成员函数，默认参数为0 return 0;&#125; 运行结果如下： 2. C++中的L和_T的作用在一个字符串前加 L表示将ANSI字符串转换为unicode的字符串，每个字符占两个字节12strlen("abc") = 3;strlen(L"asd") = 6; _T宏可以把一个引号引起来的字符串，根据你的环境设置，使得编译器会根据编译目标环境选择合适的（Unicode还是ANSI）字符处理方式，如果你定义了UNICODE，那么_T宏会把字符串前面加一个L。这时 _T(“ABCD”) 相当于 L”ABCD” ，这是宽字符串。如果没有定义，那么_T宏不会在字符串前面加那个L，_T(“ABCD”) 就等价于 “ABCD” 3. C++调用Python函数的方法 这里使用vs2015编译程序，首先要设置项目的属性，把python的include目录和libs目录包含到项目中，设置如下： python程序如下： 1234 # pythondef convertStrToNum(string): result = eval(string) return result 这里的python程序当做模块来对待，文件夹名称为strToNum，文件名strToNum.py，在同一个文件夹下有init.py文件(内容可为空)来表示模块。 在C++程序中调用python函数时注意：python语句写成模块的形式；将python模块的路径添加到系统中，否则c++程序无法找到python模块，最好使用相对路径； 步骤： 1.Py_Initialize()初始化python; 2.定义PyObject相关指针， 载入python模块 加载模块函数 添加参数列表 调用python函数 定义C++数据变量，转换python返回的参数为C++的数据类型，并用该变量接收 3.Py_Finalize()释放资源 c++程序如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 #include "iostream"#include "Python.h"#include "string"#include "cstring"using namespace std;int main()&#123; Py_Initialize(); //PyRun_SimpleString("x=eval('2 + 3*2')"); //运行单个python语句 //PyRun_SimpleString("print(x)"); //PyArg_Parse(x, "i"); // 将Python工作路径切换到待调用模块所在目录，一定要保证路径名的正确性 string path = ".\\strToNum"; //相对路径，windows下 string chdir_cmd = string("sys.path.append(\"") + path + "\")"; const char* cstr_cmd = chdir_cmd.c_str(); PyRun_SimpleString("import sys"); PyRun_SimpleString(cstr_cmd); PyRun_SimpleString("import os"); PyRun_SimpleString("print(os.getcwd())"); //获取当前路径 PyRun_SimpleString("print(sys.path)"); PyObject *pModule = NULL; //接收python模块 PyObject *pFunc = NULL; //接收pyhton函数 PyObject *pResult = NULL; //接收python函数的返回结果 double result = 0; //C++中接收最终计算结果的变量 pModule = PyImport_ImportModule("strToNum"); if (!pModule) // 加载模块失败 &#123; cout &lt;&lt; "[ERROR] Python get module failed." &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Python get module succeed." &lt;&lt; endl; pFunc = PyObject_GetAttrString(pModule, "convertStrToNum"); if (!pFunc || !PyCallable_Check(pFunc)) // 验证是否加载成功 &#123; cout &lt;&lt; "[ERROR] Can't find funftion (convertStrToNum)" &lt;&lt; endl; return 0; &#125; cout &lt;&lt; "[INFO] Get function (convertStrToNum) succeed." &lt;&lt; endl; PyObject *pArgs = PyTuple_New(1); //新建数组保存传入python函数的参数 PyTuple_SetItem(pArgs, 0, Py_BuildValue("s", "1 + 2*4.3 -1")); //PyObject *pArgs = Py_BuildValue("23"); pResult = PyEval_CallObject(pFunc, pArgs); //调用python函数 PyArg_Parse(pResult, "d", &amp;result); //python函数的返回结果转换为double cout &lt;&lt; "result:" &lt;&lt; result &lt;&lt; endl; Py_Finalize(); //释放资源 return 0;&#125; 参考的文章： C++调用python返回值 调用python的类函数 使用与pyhton的C++扩展]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++调用Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[1. python里*args和**kwargs的用法引入参数*args和**kwargs，两个都是python中的可变参数。*args表示任何多个无名参数，它是一个tuple**kwargs表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前12345678910def foo(*args, **kwargs): print 'args = ', args print 'kwargs = ', kwargs print '---------------------------------------'if __name__ == '__main__': foo(1,2,3,4) #参数只传到*args中 foo(a=1,b=2,c=3) #参数只传到**kwargs中 foo(1,2,3,4, a=1,b=2,c=3) #参数可以传到*args和**kwargs中 foo('a', 1, None, a=1, b='2', c=3) 运行结果：123456789101112args = (1, 2, 3, 4)kwargs = &#123;&#125;---------------------------------------args = ()kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = (1, 2, 3, 4)kwargs = &#123;'a': 1, 'c': 3, 'b': 2&#125;---------------------------------------args = ('a', 1, None)kwargs = &#123;'a': 1, 'c': 3, 'b': '2'&#125;--------------------------------------- 2.python对txt文件的操作2.1 使用open() 函数读取文本内容，本函数是打开一个文件并返回文件对象。如果文件不能打开，抛出异常OSErroropen(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=T)参数mode是指明打开文件的模式。默认值是’r’，表示使用文本的方式打开文件来读取。 ‘r’表示打开文件只读，不能写。 ‘w’表示打开文件只写，并且清空文件。 ‘x’表示独占打开文件，如果文件已经存打开就会失败。 ‘a’表示打开文件写，不清空文件，在文件后尾追加的方式写入。 ‘b’表示二进制的模式打开文件。 ‘t’表示文本模式，默认情况下就是这种模式。 ‘+’打开文件更新（读取或写入）。 缺省时的模式就相当于’rt’。比如’w+b’就是打开文件进入读写，把文件清空；’r+b’打开文件，但不把文件清空打开文件的操作常使用异常捕捉来 str.strip(rm)方法,去除字符串开头和结尾的rm字符，readline()获取的是一行文本的字符串形式1234567891011121314151617def open_file(filename): """打开一个文件，存储到列表中，并返回该列表""" try: with open(filename) as file_open: #打开文件，因为只有一行，所以不用使用循环 data = file_open.readline() # [james,james2,james3] = data.strip().split(',', 2) #方法串链，从左向右作用 file_data = data.strip().split(',') """split方法返回字符串列表，如果只是一个标识符接受，则不会报错 如果是[list1,list2,...]的形式则有可能因为接受数据的列表元素个数，与返回的 字符串列表的个数不一致而导致ValueError""" return file_data except IOError as ioerr: print 'IOError:' + str(ioerr) return None except ValueError as valerr: print 'ValueError:' + str(valerr) return None (role, line_spoken) = each_line.split(&#39; ,&#39;)，多重赋值(),[]均可以接受数据-字符串列表，each_line本身不会被分割，保持不变[role, line_spoken] = each_line.split(&#39;, &#39;,1)[string1, string2, string3] = each_line.split(&#39;, &#39;, 2)如果分割后的字符首位有“空格”，也会把其当成字符串第二个参数表示使用的分割符的个数，使用1则分为两个部分，如果不加则表示只要存在分隔符就会分解,n个分隔符分为n+1个部分，空字符也算入被分割的部分 2.2 使用open() 函数和file_object.write() 方法写入文本方法一、增加额外的逻辑来处理异常,使用finally来关闭文件对象1234567891011121314try: #文件写入过程 man_file = open('man_data.txt', 'w') #新建文件 other_file = open('other_data.txt', 'w') """ write()与print都可以写入数据，当print可以由字符串或列表写入， write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # print &gt;&gt; man_file, man #文件对象里传入数据 # print &gt;&gt; other_file, other man_file.write(str(man)) other_file.write(str(other))except IOError: print 'File error.'finally: #无论有无异常，此句都会执行， man_file.close() other_file.close() 方法二、with处理文件异常,不用考虑关闭文件对象123456789101112131415try: #文件写入过程 # with open('man_data.txt', 'w') as man_file: #新建文件 # # print &gt;&gt; man_file, man #文件对象里传入数据 # man_file.write(str(man)) # with open('other_data.txt', 'w') as other_file: # """ write()与print都可以写入数据，当print可以由字符串或列表写入， # write()括号里只能是字符串，所以列表需要先转换后字符串再放到括号里""" # # print &gt;&gt; other_file, other # other_file.write(str(other)) with open('man_data.txt', 'w') as man_file, open('other_data.txt', 'w') as other_file: #两个语句合并为一个with语句 man_file.write(str(man)) other_file.write(str(other))except IOError as err: print 'File error:' + str(err) 2.3实例打开train_data.txt，读取其中的前四行，然后存储到train_data2.txt文件里 1234567891011121314151617181920212223# encoding:utf-8# file.readlines()读取数据的行数，'行数据\n' 是该方法输出列表的每行数据的元素attribute_data = []try: with open('./train_data.txt') as file, open('./train_data2.txt','w') as file2: raw_number = len(file.readlines()) # 计算文件的总行数 file.seek(0) # 回到第一行，因为每次使用readline，文本都会后退一行 for i in range(raw_number): # 计算文件的总行数，设计循环逐行读入数据 text_line = file.readline() # 每次调用该函数使文件下移一行 # temp_file = text_line.strip().split(' ', 32) # temp_file存储分割后的数据列表 # attribute_data = temp_file[0:2] + temp_file[12:32] # 存储要使用的数据列 temp_file = text_line.strip().split(' ', 4) # temp_file存储分割后的数据列表 attribute_data = temp_file[0:4] # 存储要使用的数据列 for data in attribute_data: # 逐行写入数据,只能每个字符分别读入，才可以在数据中间插入空格 file2.writelines(data) file2.writelines(' ') # 数据间加入空格 file2.writelines('\n') # 数据换行except IOError as err: print 'File error:' + str(err)print attribute_data ` 3.python函数shutil，实现文件的复制使用shutil.copy(str_file1,str_file2)将文件str_file1，复制到文件str_file2的位置 4.python实现读取文件夹里文件名功能123import os path = 'the path of the directory' # 读取文件路径list_name = os.listdir(path) # 读取路径下文件和文件夹的名 则list_name就是文件夹里所以子文件夹和文件的列表，可以通过os.path.isfile和os.path.isdir来对列表里的项进行判断看是文件还是文件夹。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
